##### Day-1 [7-04-2025]

# Introduction to Pandas :

- It is the most important and **commonly used library in datascience domain**.
- Pandas is freeware and opensource.
- Pandas is built on top of Numpy.
- It allows fast analysis, data cleaning and preparation.
- **Perfoemace wise and productivity wise pandas is too good** to use.
- It can  work with data from a wide variety of sources like fies etc...
- By using pandas we can manipulate data very easily with very less code and in very less time.

>Note:
> - Numpy is a data analysis library.
> - Matplotlib is a data visualization library.
> - Pandas is **both data analysis and data visualization library**. Pandas data analysis is based on Numpy where as data visualization is based on matplotlib.

[Pandas website](https://pandas.pydata.org/)
Latest version: 2.2.3(Sep 20, 2024)

From Official Documentation:
- pandas is a fast, powerful, flexible and easy to use open source data analysis and manipulation tool, built on top of the Python programming language.

How to install:
>		pip install pandas

How to check installation:
```py
>>> import pandas as pd
>>> pd.__version__ #'2.0.3'
```
Important Topics:
-------
- Series
- DataFrames
- Missing Data
- GroupBy
- Merging,Joining and Concatenating
- Operations
- Data input and output etc....

## Series :

- It is one of **key data structure** in pandas.
- It is **one-dimensional labeled arrays**. i.e a sequence of values associated with labels.

Creation of Series from python list:
----
```py
import pandas as pd
books_list = ['Python','Java','DataScience']
s = pd.Series(books_list)
print(type(s))
print(s)
```
>[!Note]
> 1. In the above Series object, we have 3-values (python,java,DS) associated with index labels (0,1,2), which are generated automatically by pandas.
> 2. For a string values, **dtype is considered as object**.
> 3. The **default index labels are integers starts from 0**. But we **can define any other type index labels** also.
> 4. The **index labels need not be unique**.
> 5. The Series can have **any type even hetrogenious** also.
> 6. Index labels and values need not be homogenious.

Ex:
```py
marks_list = [70,80,90]
s = pd.Series(marks_list)
print(s)
```
Ex:
```py
salaries_list = [1000.5,2000.6,3000.7]
s = pd.Series(salaries_list)
print(s)
```
Ex:
```py
hetro_list = [10,'Mahesh',10.5,True]
s = pd.Series(hetro_list)
print(s)
```


Creation of Series from python dict:
--------------
Ex-1
```py
books_dict = {0:'Python',1:'Django',2:'REST_API'}
s = pd.Series(books_dict)
print(s)
```
Ex-2
```py
books_dict = {'Book-1':'Python','Book-2':'Django','Book-3':'REST_API'}
s = pd.Series(books_dict)
print(s)
```

From Source code of pandas:
--------------------
```py
# Series class


# error: Cannot override final attribute "ndim" (previously declared in base
# class "NDFrame")
# error: Cannot override final attribute "size" (previously declared in base
# class "NDFrame")
# definition in base class "NDFrame"
class Series(base.IndexOpsMixin, NDFrame):  # type: ignore[misc]
    """
    One-dimensional ndarray with axis labels (including time series).

    Labels need not be unique but must be a hashable type. The object
    supports both integer- and label-based indexing and provides a host of
    methods for performing operations involving the index. Statistical
    methods from ndarray have been overridden to automatically exclude
    missing data (currently represented as NaN).

    Operations between Series (+, -, /, \\*, \\*\\*) align values based on their
    associated index values-- they need not be the same length. The result
    index will be the sorted union of the two indexes.

    Parameters
    ----------
    data : array-like, Iterable, dict, or scalar value
        Contains data stored in Series. If data is a dict, argument order is
        maintained.
    index : array-like or Index (1d)
        Values must be hashable and have the same length as `data`.
        Non-unique index values are allowed. Will default to
        RangeIndex (0, 1, 2, ..., n) if not provided. If data is dict-like
        and index is None, then the keys in the data are used as the index. If the
        index is not None, the resulting Series is reindexed with the index values.
    dtype : str, numpy.dtype, or ExtensionDtype, optional
        Data type for the output Series. If not specified, this will be
        inferred from `data`.
        See the :ref:`user guide <basics.dtypes>` for more usages.
    name : Hashable, default None
        The name to give to the Series.
    copy : bool, default False
        Copy input data. Only affects Series or 1d ndarray input. See examples.

    Notes
    -----
    Please reference the :ref:`User Guide <basics.series>` for more information.

    Examples
    --------
    Constructing Series from a dictionary with an Index specified

    >>> d = {'a': 1, 'b': 2, 'c': 3}
    >>> ser = pd.Series(data=d, index=['a', 'b', 'c'])
    >>> ser
    a   1
    b   2
    c   3
    dtype: int64

    The keys of the dictionary match with the Index values, hence the Index
    values have no effect.

    >>> d = {'a': 1, 'b': 2, 'c': 3}
    >>> ser = pd.Series(data=d, index=['x', 'y', 'z'])
    >>> ser
    x   NaN
    y   NaN
    z   NaN
    dtype: float64

    Note that the Index is first build with the keys from the dictionary.
    After this the Series is reindexed with the given Index values, hence we
    get all NaN as a result.

    Constructing Series from a list with `copy=False`.

    >>> r = [1, 2]
    >>> ser = pd.Series(r, copy=False)
    >>> ser.iloc[0] = 999
    >>> r
    [1, 2]
    >>> ser
    0    999
    1      2
    dtype: int64

    Due to input data type the Series has a `copy` of
    the original data even though `copy=False`, so
    the data is unchanged.

    Constructing Series from a 1d ndarray with `copy=False`.

    >>> r = np.array([1, 2])
    >>> ser = pd.Series(r, copy=False)
    >>> ser.iloc[0] = 999
    >>> r
    array([999,   2])
    >>> ser
    0    999
    1      2
    dtype: int64

    Due to input data type the Series has a `view` on
    the original data, so
    the data is changed as well.
    """
```
The 5 parameters of Series Constructor :
-----------------------
1. data parameter
2. index
3. dtype
4. name	
5. copy	

1).Data Parameter
----------
- data parameter can be used to represent data which is required to store inside Series object.
```py
books_dict = {'Book-1':'Python',10:20,10.5:20.6,'Book-2':'DS'}
s = pd.Series(data = books_dict)
print(s)
```

Ways to create Series / Valid Series creation :
```py
	s = pd.Series(data = [10,20,30])
	s = pd.Series(data = {0:'A',1:'B',2:'C'})
	s = pd.Series(data = {'A':'Apple','B':'Ball','C':'Cat'})
	s = pd.Series(data = np.array([10,20,30]))
	s = pd.Series(data = 10)
	s = pd.Series(data = 'Mahesh')
```
2).index parameter:
------------------
- We can use index parameter to **define our own index values**.
- The values need not be unique.
- If we are not using index, then pandas will generate **default index labels** which are integers starts from 0.
- The number of index values should be same as the number of values of data parameter.

Ex:
```py
name_list = ['Sunny','Bunny','Vinny']
s = pd.Series(data = name_list,index=['S','B','C'])
print(s)

# Note:
s = pd.Series(data = name_list,index=['S','B'])
#	ValueError: Length of values (3) does not match length of index (2)
```
Duplicate index labels possible.

```py
name_list = ['Sunny','Bunny','Vinny','Binny']
s = pd.Series(data = name_list,index=['S','B','C','B'])
print(s)
```
If the data is dict, then matched indexes only will be considered from the dict
```py
name_dict = {'S':'Sunny','B':'Bunny','V':'Vinny','C':'Chinny'}
s = pd.Series(data = name_dict,index=['S','B',])
print(s)
```
Ex:From pandas source code
```py
>>> d = {'a': 1, 'b': 2, 'c': 3}
>>> ser = pd.Series(data=d, index=['x', 'y', 'z'])
>>> ser
x   NaN
y   NaN
z   NaN
dtype: float64

#    Note that the Index is first build with the keys from the dictionary.
#    After this the Series is reindexed with the given Index values, hence we
#    get all NaN as a result.
```
##### Day-2 [8-04-2025]

RangeIndex:
------------------
- If we are not providing index parameter, then pandas will consider **default index values from RangeIndex(0,1,2,....n) object internally**.

Ex:
```py
name_list = ['Sunny','Bunny','Vinny','Chinny']
s = pd.Series(data = name_list)
print(s.index)#RangeIndex(start=0, stop=4, step=1)
```
Ex:
```py
name_list = ['Sunny','Bunny','Vinny','Chinny']
s = pd.Series(data = name_list)
s.index = pd.RangeIndex(start=10,stop=14,step=1)
print(s.index)
print(s)
```
Ex:
```py
s.index = pd.RangeIndex(start=10,stop=17,step=2)
print(s.index)
print(s)
```
3). dtype parameter :
-----------------
- We can use **dtype parameter to specify data type** for the output Series.

Ex:
```py
num_list = [10,20,30,40]
s1 = pd.Series(data=num_list,dtype='float')
s2 = pd.Series(data=num_list,dtype='bool')
s3 = pd.Series(data=num_list,dtype='str')
print(s1)
print(s2)
print(s3)
```
4). name parameter :
---------------
- We can assign name also to the Series. For this we have to use name parameter. The default name is None.
```py
num_list = [10,20,30,40]
s = pd.Series(data=num_list)
print(s.name)#None
```

```py
s = pd.Series(data=num_list,name='My Favourite Numbers')
print(s)

# We can also set name as:
s.name = 'My Numbers'
```
Setting name to the indexs:
-------------------------
```py
s.index.name = 'Default Indexes'
```
5). copy parameter :
-------------------
- This parameter decides whether it is required to create **View or Copy**.
- The default value is **False, i.e new object won't be created**.
- It is applicable only for **ndarray input**.

Ex-1: For list input
```py
num_list = [10,20]
s = pd.Series(data=num_list,copy=False)
s.iloc[0] = 333
print(s)
print(num_list)
# Even we changed Series content, that change not reflected to the list input.
```
Ex-2: For ndarray input
```py
arr = np.array([10,20])
s = pd.Series(data=arr,copy=False)
s.iloc[0] = 333
print(s)
print(arr)
# The changes of Series object reflected automatically inside ndarray input.

s = pd.Series(data=arr,copy=True)
# Even input is ndarray, separate copy got created because copy=True.
```
Exercise:
1. Create a python list named with student_list with 5 student names?
2. Create another python list named with marks_list with corresponding student marks?
3. Create a Series object that stores student marks as values and student names as index labels. Assign name 'Students' for this Series?


Sol:
```py
student_list = ['Sunny','Bunny','Vinny','Chinny','Pinny']
marks_list = [40,50,60,70,80]
ser = pd.Series(data=marks_list,index=student_list,name='Students')
print(ser)
```
4. Create a python dictionary with student_list and marks_list and create a Series object with that dictionary?
sol:
```py
student_list = ['Radhika','Bunny','Vinny','Chinny','Lilly']
marks_list = [40,50,60,70,80]
# ceate a dict combining two list
#students_dict = dict(zip(student_list,marks_list))
students_dict = {name:marks for name,marks in zip(student_list,marks_list)}
ser = pd.Series(data=students_dict,name='Students')
print(ser)
```
Accessing values from Series by using head() and tail() methods :
---------------
head():
-----

>Series.head(n=5)
> - Return the **first 'n' rows**. The default value for **n is 5**.
> - For **negative values of n**, this function **returns all rows except the last 'n' rows**.

Ex:
```py
import pandas as pd
s = pd.Series([i for i in range(50)])
print(s)
print(s.head())#Returns first 5 values
print(s.head(3))#Returns first 3 values
print(s.head(n=-46))#Returns the rows except last 46 rows. i.e first 4-rows.
```
tail()
----
> Series.tail(n=5)
> - Return the **last 'n' rows**. The default value for **n is 5**.
> - For **negative values of n**, this function **returns all rows except the first 'n' rows**.

```py
s = pd.Series([i for i in range(50)])
print(s.tail()) #Return last 5-rows
print(s.tail(3)) #Returns last 3-rows
print(s.tail(n=-3)) #Return all rows except first 3-rows
```
Q.Returns values from 10th to 15th by using head() and tail() methods?
```py
s = pd.Series([i for i in range(50)])
print(s.head(16).tail(6))
```
##### Day-3 [9-04-2025]

Extract values from Series by index position [index based selection]
------------------------------------------
Syn:
- s[x]
	- x can be index value
	- x can be list of indices
	- x can be slice also

Ex:
- s[5] ---> Returns values present at index 5
- s[[1,3,5]] ---> Returns Series of values present at indices 1,3 and 5
- s[2:6] ---> Returns Series of values from 2nd index to 5th index.

Ex: Series contains all upper case alphabet symbols as values
```py
# 1st way:
alphabets = list('ABCDEFGHIJKLMNOPQRSTUVWXYZ')
s = pd.Series(data=alphabets)
print(s)

# 2nd way:
from string import ascii_uppercase
alphabets = list(ascii_uppercase)
s = pd.Series(data=alphabets)
print(s)

# Q.To get first character?
s[0]

# Q.To get last character?
s[-1] #not supported
s[25]		or		s[s.size-1]

# Q.To get character present at 10th index position
s[10]

# Q.To get characters present at indices:5,10,15,20
s[[5,10,15,20]]

# Q.To get characters from 10th index to 16th index?
s[10:17]

# Q.To get every other character i.e every alternative character?
s[::2]

# Q.To get first 5 characters?
s[0:5] or s[:5]	or s.head() or s.head(5) or s.head(n=5)

# Q.To get last 3 characters?
s[-3:] or s[s.size-3:] or s.tail(3) or s.tail(n=3)

# Note:-ve indexing is applicable only for slice input.

s[-1]#Invalid
s[[-1,-2,-3]]#Invalid
s[-3:]#Valid

# Note:
	# Accessing based on position is applicable even for custom labeled Series also.
```
Extracting values from Series by labels [Label based selection] :
--------
Syn:
- s['label']
- s[['label-1','label-2','label-3']]
- s[label1:label3]

Sample code to append 'Label_' for every index:
---------------------------------------
Syn:
- map(function,sequence)
```py
alphabets = list('ABCDEFGHIJKLMNOPQRSTUVWXYZ')
#print(list(map(lambda x:'Label_'+x,alphabets)))
print(['Label_'+x for x in alphabets])
```
pandas inbuilt add_prefix() and add_suffix() methods :
----------------------------------------
```py
alphabets = list('ABCDEFGHIJKLMNOPQRSTUVWXYZ')
s = pd.Series(data=alphabets,index=alphabets)
#s = s.add_suffix('_Label')
s = s.add_prefix('Label_')
print(s)

# Q.To get first character?
s[0] or s['Label_A']

# Q.To get 10th character?
s[9] or s['Label_J']

# Q.To get values from 'Label_H' to 'Label_S'
s['Label_H':'Label_S']
```
> [!Note]
> 1. In the index based slicing, **end/stop attributes is not inclusive**.  
> s[2:5] - here 5 is not inclusive and it returns values from 2nd index to 4th index.
>
> 2. But in Lable based slicing, **end/stop attribute is inclusive**.  
> s['Label_H':'Label_S']  ---> 'Label_S' is inclusive.

Using dot notation to access data by labels:
-----------------------
Syn:
- s.label
- Returns the value associated with specified label

Ex:
```py
s.Label_Z #Z
```
Limitation: But this approach is **not applicable for index** and here we **cannot use slice operator**.

Ex:
```py
	s.0 #Invalid
	s.Label_A:Label_E #Invalid
```
Extracting values by using get() method
-----------------------------------------------------------
- In position based selection or label based selection, if the **specified index or label is not available then we will get an error**.
```py
s[100] #IndexError
s['Label_ZZ'] #KeyError: 'Label_ZZ'
```
- To overcome this problem we should **use get() method**.
- If the specified index or label is not available then we will get None but not error.

```py
print(s.get(100))#None
print(s.get('Label_ZZ'))#None
```
- Even in the case of get() method, we **can provide default value if the specified index or label is not available**.
```py
print(s.get(100,default='default value'))
print(s.get('Label_ZZ',default='default value'))
# Here default value will be considered because specified key and label are not available.
```


Ex:
```py
print(s.get(0))
print(s.get([0,3,7]))
print(s.get('Label_D'))
print(s.get(['Label_D','Label_G','Label_M']))
```
##### Day-4 [10-04-2025]

Extracting values by using loc and iloc indexers:
-------------------------------------
- loc indexer ---> For label based selection
- iloc indexer ---> For position based selection

- iloc ---> integer loc

iloc indexer:
---------
- For position based selection. The argument should be index.
Syn:
	- s.iloc[i]
	- s.iloc[[0,1,2]]
	- s.iloc[m:n]
Ex:
```py
import pandas as pd
s = pd.Series([10,20,30,40,50])
print(s)

# Q.To get first value?
s[0] or s.iloc[0]

# Q.To get values at indices:0,1,2
s.iloc[[0,1,2]]

# Q.To get the first 3 values
s.iloc[:3]

# Q.To get last value?
s[-1] #Invalid
s.iloc[-1] #Valid
```
loc indexer:
----------
- For label based selection.
Syn:
	- s.loc[label]
	- s.loc[[label1,label2,label3]]
	- s.loc[labelm:label:n]#here labeln is inclusive

Ex:
```py
alphabets = list('ABCDEFGHIJKLMNOPQRSTUVWXYZ')
s = pd.Series(data=alphabets,index=alphabets)
s = s.add_prefix('Label_')
print(s)

# Q.To get value associated with Label_A
s.loc['Label_A']
s.loc[0] #invalid

# Q.To get values associated with labels:Label_A, Label_K, and Label_Y
s.loc[['Label_A','Label_K','Label_Y']]

# Q.To get values from Label_H to Label_N?
s.loc['Label_H':'Label_N']

# Q.To get alternative values from Label_H to Label_N?
s.loc['Label_H':'Label_N':2]
```


Q.Assume 's' is the Series object, which of the following are valid syntactically?

1. s[0]
2. s['Label_A']
3. s.iloc[0]
4. s.iloc['Label_A']
5. s.loc[0]
6. s.loc['Label_A']

Ans: 1,2,3,6

>[!Note]
> 1. The main advantage of loc and iloc indexers when compared normal indexer is performance will be improved.
> 2. iloc and loc indexers are commonly used in dataframes.
> 3. In normal indexer we cannot pass negative index value. But in iloc indexer we can pass.
> 4. If we are depending on default indexes then there is no difference between loc and iloc indexers.
>
> Ex:
> ```py
> s = pd.Series([10,20,30,40,50])
> print(s[0])
> print(s.iloc[0])
> print(s.loc[0])
> ```
>
Boolean masking for condition based selection:
-----------------
- Condition based selection.
- We have to provide array of boolean values and selects from Series where True value present.
- It is applicable for normal **indexer, loc and iloc** indexers also.

- Syn:
	- s[[True,False,....]]
	- s.loc[[True,False,....]]
	- s.iloc[[True,False,....]]
	- s.get([True,False,.....])

Ex:
```py
s = pd.Series([10,20,30,40,50])
print(s[[True,False,False,True,True]])
print(s.loc[[True,False,False,True,True]])
print(s.iloc[[True,False,False,True,True]])
print(s.get([True,False,False,True,True]))
```
>[!Note]  
> The number of boolean values passed and the number of values in Series must be matched, otherwise we will get an error.
```py
s = pd.Series([10,20,30,40,50])
print(s[[True,False,False,True]])#IndexError: Boolean index has wrong length: 4 instead of 5
```
But in the case of get() method we wont get any error and just we will get None.
print(s.get([True,False,False,True]))#None

>[!Note]  
>	This approach is very helpful to get values based on some condition.
```py
# Ex-1:To select all values which are > 25
s = pd.Series([10,20,30,40,50])
print(s[s>25])

# Ex-2:To select values which are divisible by 3
print(s[s%3 == 0])
```
Usage of callables in Selecting elements:
----------------------------
- We can use callable object like function while selecting values from the Series.
- It should return anything, which should be valid argument for indexers and get method.

Ex:
```py
import pandas as pd
s = pd.Series([i for i in range(20)])

def odd_selections(s):
	return [True if i%2==1 else False for i in range(s.size)]

print(s[odd_selections])
```
We can pass callable object to **normal indexer, loc and iloc indexers and for get()** method also.

```py
import pandas as pd
s = pd.Series([i for i in range(20)])
print(s[lambda s:[True if i%2==1 else False for i in range(s.size)]])
print(s.loc[lambda s:[True if i%2==1 else False for i in range(s.size)]])
print(s.iloc[lambda s:[True if i%2==1 else False for i in range(s.size)]])
print(s.get(lambda s:[True if i%2==1 else False for i in range(s.size)]))
```
Summary: How to get values from Series object
------------------------------------
```py
1. s.head(n)
2. s.tail(n)
3. s[index]
4. s[[index1,index2,index3]]
5. s[indexm:indexn]#here indexn is not inclusive
6. s[label]
7. s[[label1,label2,label3]]
8. s[labelm:labeln]#here labeln is inclusive
9. s.iloc[index]
10. s.iloc[[index1,index2,index3]]
11. s.iloc[indexm:indexn]#here indexn is not inclusive
12. s.loc[label]
13. s.loc[[label1,label2,label3]]
14. s.loc[labelm:labeln]#here labeln is inclusive
15. s.get(index)
16. s.get([index1,index2,index3])
17. s.get(label)
18. s.get([label1,label2,label3])
```
- Even we can **provide boolean mask values and callable objects** as args.

##### Day-1 [27-02-2025]
# Python for Data Science, ML, DL and AI:
Devops --> Regular core python knowledge concise code  
Rich libraries --->70 to 90% our libraries 10% we have to write the code.

## What is this line in python?
```python
import numpy as np
# Numpy-->Entry point from python for DS
# Numpy-->Numerical Python Library
```
## How to install Numpy?
```python
>>>pip install numpy
```

## How to check version:
```python
D:\Mahesh_Classes>py
>>> import numpy as np
>>> np.__version__
```
## What is the need of Numpy?
Python performs basic mathematical operations.

```python
a = 10
b = 20
a+b
a-b
a/b
a*b

math.sqrt(4)
```
But in Data Science, ML, DL and AI required complex matghematical operations....

* 1. Numpy defines several functions to perform **complex mathematical operations**.
* 2. To fullfill performance gaps most of the Numpy is **implemented in C-Language** superfast
* 3. nd array(To store large data in nd array for matplotlib graph style) -->n dimensional array or numpy array

```py
# Ex:
# matrix with all zero 10X10 shape
# l = [[0,0,0,0...],[],[],......[]]

	>>>import numpy as np
	>>>a = np.zeros((10,10))
	>>>a

# If you want only int type:
	>>> a = np.zeros((10,10),dtype=int)

# list of 100-numbers:
	>>>a = np.arange(1,101)
	>>>a

# pls convert into 2-dimension array
	>>>a.reshape(10,10)

# Identity matrix?
	>>>a = np.identity(3)
	>>>a = np.identity(5)
```
* 4. Data Analysis:  
     2 crore samples are analyzed  
     100 -->points  
     new patient--->corona  

## History of Numpy:
Origin of Numpy---->Numeric Library  
Numeric Library--->**Jim Hugunin**  
Numpy-->**Travis Oliphant(2005)**  
Open source library and freeware  

## Q.In which language Numpy was written?  
**C and Python**

## Q.What is nd array in numpy?
The fundamental data type to store our data : nd array
```python
>>> a = np.identity(5)
>>> type(a) #<class 'numpy.ndarray'>
>>> help(np.ndarray)
Help on class ndarray in module numpy:
arrays are objects of ndarray class present in numpy module
```
Array: An indexed collection of homogenious elements

1-D array	---> Vector  
2-D array	---> Matrix  
.  
.  
.  
n-D array	---> No name  

#### Day-1 https://youtu.be/z2Hq-8-fWrY

##### Day-2 [27-02-2025] 
# Numpy Basic Introduction

## Ex: What is the need of Numpy
```py
Boys and Girls are attending Mahesh sir datascience class.
For boys fee is $3 and for girls fees is $8, For a certain batch 2200 people attended and $10100 fee collected. How many boys and girls attended for that batch.

x --->no of boys
y --->no of girls

x + y = 2200
3x + 8y = 10100

coefficient matrix:
a =	1 1
	3 8
value matrix
b = [2200,10100]

numpy.linalg.solve(a,b)

>>> import numpy as np
>>> a = np.array([[1,1],[3,8]])
>>> a
array([[1, 1],
       [3, 8]])
>>> b = np.array([2200,10100])
>>> b
array([ 2200, 10100])
>>> np.linalg.solve(a,b)
array([1500.,  700.])
```
## Array:
An indexed collection of homogenious data elements.

## How to create arrays in python.
Inbuilt arrays concept is not there in python

### 2-ways:
* 1. By using array module
* 2. By using numpy module

### 1. By using array module (Not recommended)
```py
import array
a = array.array('i',[10,20,30])#i represents type:int array
print(type(a))
print(a)
print('Elements one by one:')
for x in a:
	print(x)

Note:
	array module is not recommended because much library support is not available.
```

###  2. By using numpy module:
```py
import numpy
a = numpy.array([10,20,30])
print(type(a))
print(a)
for x in a:
	print(x)
```
## Python's List vs Numpy ndarray:
### 1. Similarities:
* Both are used to store data.  
* The order will be preserved in both. Hence indexing and slicing concepts are applicable.  
* Both are mutable, i.e we can change the content.  

### 2. Differences:
* list is pythons inbuilt type. We have to install and import numpy explicitly.
* list can contain hetrogenious elements. But array contains only homogenious elements.
```py
import numpy
l = [10,10.5,'Sunny',True]
print(l)#[10, 10.5, 'Sunny', True]
a = numpy.array(l)
print(a)#['10' '10.5' 'Sunny' 'True']
```
* On list we cannot perform vector operations. But on ndarray we can perform vector operations
```py
>>>l = [10,20,30,40]
>>>import numpy as np
>>>a = np.array(l)
>>>a #array([10, 20, 30, 40])
>>>l + 2 #Invalid
>>>a + 2 #array([12, 22, 32, 42])
>>>a / 2 #array([ 5., 10., 15., 20.])
>>>l * 2 #[10, 20, 30, 40, 10, 20, 30, 40]
>>>a * 2 #array([20, 40, 60, 80])
```
* Arrays consumes less memory than list.
* Array are superfast when compared with list.
* Numpy arrays are more convinient to use while performing complex mathematical operations.

## How to create Numpy Arrays:
* 1. array()
* 2. arange()
* 3. linspace()
* 4. zeros()
* 5. ones()
* 6. full()
* 7. eye()
* 8. identity()
* 9. empty()
* 10. numpy.random
 	* 1. randint()
 	* 2. arnd()
 	* 3. uniform()
 	* 4. randn()
  	* 5. normal()
  	* 6. shuffle()  

### 1. Creation of numpy arrays by using array():
```py
## For the given list or tuple
>>>import numpy as np
>>>help(np.array)

## 1-D array:
>>> l = [10,20,30]
>>> type(l)#<class 'list'>
>>> a = np.array(l)
>>> type(a)#<class 'numpy.ndarray'>
>>> a #array([10, 20, 30])
>>> a.ndim #1
>>> a.dtype #dtype('int32')

## Note:
	a.ndim--->To know dimension of ndarray
	a.dtype--->To know data type of elements

## 2-D array creation:
[[10,20,30],[40,50,60],[70,80,90]]----->Nested List

>>> a = np.array([[10,20,30],[40,50,60],[70,80,90]])
>>> type(a) #<class 'numpy.ndarray'>
>>> a
>>> a.shape #(3, 3)
>>> a.ndim #2
>>> a.size #9

## To create 1-D array from the tuple
>>> a = np.array(('sunny','bunny','vinny'))
>>> a.ndim #1
>>> a.shape #(3,)
>>> a.dtype #dtype('<U5')

Note:Array contains only homogenious elements.
If the list contains hetrogenious elements:Upcasting will be performed.

>>> a = np.array([10,20,10.5])
>>> a #array([10. , 20. , 10.5]) Upcasting int to float
>>> a.dtype #dtype('float64')

>>> a = np.array([10,20,'a'])
>>> a #array(['10', '20', 'a'], dtype='<U11')

## How to create a particular type:
We have to use dtype parameter

>>> a = np.array([10,20,30.5],dtype=int)
>>> a #array([10, 20, 30])
>>> a = np.array([10,20,30.5],dtype=bool)
>>> a #array([ True,  True,  True])
>>> a = np.array([10,20,30.5],dtype=float)
>>> a #array([10. , 20. , 30.5])
>>> a = np.array([10,20,30.5],dtype=complex)
>>> a #array([10. +0.j, 20. +0.j, 30.5+0.j])

>>> a = np.array([10,'Sunny'],dtype=int) #Invalid

## How to create object type array:
Here any type of elements are allowed.

>>> a = np.array([10,'Sunny',True,10.5,10+3j],dtype=object)
>>> a #array([10, 'Sunny', True, 10.5, (10+3j)], dtype=object)

If we are not given dtype then
>>> a = np.array([10,'Sunny',True,10.5,10+3j])
>>> a #array(['10', 'Sunny', 'True', '10.5', '(10+3j)'], dtype='<U64')

array() ----> To create ndarray from the given list or tuple.
```
#### Day-2 https://youtu.be/uHsowtczZ3Y

# Day-3

### 2. Creation of ndarray by using arange() function:
```py
Python:
	range(10)==>0 to 9
	range(1,11)==>1 to 10
	range(1,11,2)==>1,3,5,7,9

>>> import numpy as np
>>> help(np.arange)
			
		 arange([start,] stop[, step,], dtype=None, *, like=None)

## Ex-1:create 1-D array 0 to 9
>>> a = np.arange(10)
>>> a #array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
>>> a.ndim #1
>>> a.shape #(10,)
>>> a.dtype #dtype('int32')
>>> a = np.arange(1,11)
>>> a #array([ 1,  2,  3,  4,  5,  6,  7,  8,  9, 10])
>>> a = np.arange(1,11,2)
>>> a #array([1, 3, 5, 7, 9])
>>> a = np.arange(1,11,3,dtype=float)
>>> a #array([ 1.,  4.,  7., 10.])
```
### 3. Creation of numpy arrays by using linspace() function:
```py
	In the specified interval, linearly spaced values.
>>>help(np.linspace)
linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None, axis=0)
	 Return evenly spaced numbers over a specified interval.

Ex:
>>> np.linspace(0,1,2) #array([0., 1.])
>>> np.linspace(0,1,3) #array([0. , 0.5, 1. ])
>>> np.linspace(0,1,4) #array([0. , 0.33333333, 0.66666667, 1. ])
>>> np.linspace(0,1)
>>> np.linspace(0,1).size #50
>>> np.linspace(0,1).shape #(50,)
>>> np.linspace(1,100,10,dtype=int) #array([1,12,23,34,45,56,67,78,89,00])

1 to 12--->11 numbers
12 to 23--->11 numbers
equally spaced values
```
### arange() vs linspace():
* arange() --> Elements will be considered in the given range based on step value.
* linspace() --> The specified number of values will be considered in the given range.

### 4. Creation of numpy arrays by using zeros() function:
```py
(10,)--->1-D array contains 10-elements

(5,2)--->2-D array contains 5-rows and 2-columns
			2-D array means collection of 1-D arrays

(2,3,4)--->3-D array
			3-D array contains a collection of 2-D arrays
			2--->2 number of 2-D arrays
			3--->The number of rows in every 2-D array
			4-->The number of columns in every 2-D array
			size:24
			
>>>help(np.zeros)
		 zeros(shape, dtype=float, order='C', *, like=None)

>>> np.zeros(4) #array([0., 0., 0., 0.])
>>> np.zeros((4,)) #array([0., 0., 0., 0.])
>>> np.zeros((4,3))
>>> np.zeros((2,3,4))
>>> np.zeros((1,3,2))

-->Perform some operations the result we have to store somewhere.
```

### 5. Creation of numpy arrays by using ones() function:
```py
Exactly same as zeros except that instead of zero array filled with 1.
fill_value:1

>>> help(np.ones)
		ones(shape, dtype=None, order='C', *, like=None)
			Return a new array of given shape and type, filled with ones.
## Ex:
>>> np.ones(10)
>>> np.ones((4,2))
>>> np.ones((4,2),dtype=int)
>>> np.ones((2,3,4),dtype=int)
```
### 6. Creation of numpy arrays by using full() function:
```py
>>> help(np.full)
		full(shape, fill_value, dtype=None, order='C', *, like=None)
			 Return a new array of given shape and type, filled with `fill_value`.

>>> np.full(10) #full() missing 1 required positional argument: 'fill_value'
>>> np.full(10,2)
>>> np.full(10,3)
>>> np.full((5,4),9)
>>> np.full((2,3,4),6)

Note:
	1). np.full(shape=(5,4),fill_value=3)
	2). np.full((5,4),fill_value=3)
	3). np.full((5,4),3)
	4). np.full(shape=(5,4),3)#positional argument follows keyword argument
```
### 7. Creation of numpy arrays by using eye() function:
```py
>>>help(np.eye)
eye(N, M=None, k=0, dtype=<class 'float'>, order='C', *, like=None)
    Return a 2-D array with ones on the diagonal and zeros elsewhere.

N--->Number of rows
M--->Number of columns
K--->Meant for diagonal
0 1 2 3 4
-1
-2
-3
-4

Ex:
>>> np.eye(2,3)
>>> np.eye(3,dtype=int)
>>> np.eye(5,dtype=int)
>>> np.eye(5,k=1,dtype=int)
>>> np.eye(5,k=-3,dtype=int)
```
### 8. Creation of numpy arrays by using identity() function:
```py
It is exactly same as eye() function except that
	1). It is always square matrix(the number of rows and number of columns always same)
	2). Only main diagnol contains 1's

identity() is a special case of eye()

>>>help(np.identity)
identity(n, dtype=None, *, like=None)
    Return the identity array.

Ex:
>>> np.identity(5)
>>> np.identity(5,dtype=int)
```
### 9. Creation of numpy arrays by using empty() function:
```py
>>>help(np.empty)
		empty(shape, dtype=float, order='C', *, like=None)
    Return a new array of given shape and type, without initializing entries.

Ex:
>>> np.empty(3)
>>> np.empty((3,3))
>>> np.empty(10)
```
### zeros() vs empty():
* If we required an array only with zeros then we should go for zeros()
* If we never worry about data, just we required an empty array for future purpose, then we should go for empty().
* The time required to create empty array is very very less when compared with zeros array.
  i.e **performance wise empty function is recommended than zeros if we are not worry about data.**
```py
#Performace comparisiob of zeros() and empty()
import numpy as np
from datetime import datetime
begin = datetime.now()
a = np.zeros((10000,300,400))
after = datetime.now()
print('Time taken by zeros:',after-begin)
a = None
begin = datetime.now()
a = np.empty((10000,300,400))
after = datetime.now()
print('Time taken by empty:',after-begin)
```
#### Day-3 https://youtu.be/rq0BWe2wYSY

##### Day-4:

## 10. Array creation by using random module:
* randint()
* rand()
* uniform()
* randn()
* normal()
* shuffle()

### 1. randint():
```py
	To generate random int values in the given range.

>>> import numpy as np
>>> help(np.randint) #Error
>>> help(np.random.randint)
		randint(low, high=None, size=None, dtype=int)
	    Return random integers from 'low' (inclusive) to 'high' (exclusive).
		[low,high)

## Ex:
>>> np.random.randint(10,20)

## 1-D array
>>> np.random.randint(1,10,size=10)

## 2-D array
>>> np.random.randint(100,size=(3,5)) 

## 3-D array
>>> np.random.randint(100,size=(2,3,4))

Ex:
>>>  np.random.randint(1,10,size=10,dtype=float)
TypeError: Unsupported dtype dtype('float64') for randint

Syn:
	randint(low, high=None, size=None, dtype=int)

int8,int16,int32,int64

>>> a = np.random.randint(1,10,size=(20,30))
>>> a.dtype #int32
>>> a = np.random.randint(1,10,size=(20,30),dtype='int8')
>>> a.dtype #int8==> Memory utilization

Ex:
>>> import sys
>>> a = np.random.randint(1,10,size=(20,30))
>>> sys.getsizeof(a) #2528
>>> a = np.random.randint(1,10,size=(20,30),dtype='int8')
>>> sys.getsizeof(a) #728
```
### How to convert from one array type to another type

```py
We have to use astype() method

>>> a = np.random.randint(1,10,size=(20,30))
>>> a.dtype #dtype('int32')
>>> b = a.astype('float')
>>> b.dtype #dtype('float64')

### 2. rand():
```py
uniform distribution	---> 10 11 9 10 11 10
normal distribution	---> 6 4 10 4 14(10 is mean value)

It will generate random float values in the range [0,1) from uniform distribution samples.

Ex:
>>> np.random.rand() #A single float value will be generated

## 1-D array
>>> np.random.rand(10)

## 2-D array
>>> np.random.rand(3,5)

## 3-D array
>>> np.random.rand(2,3,4)
```
### 3. uniform():
```py
rand() ---> range is always [0,1)
uniform() ---> customize range
	uniform(low=0.0, high=1.0, size=None)

Ex:
>>> np.random.uniform()
>>> np.random.uniform(10,20)

1-D array: >>> np.random.uniform(10,20,size=5)
2-D array: >>> np.random.uniform(10,20,size=(3,4))
3-D array: >>> np.random.uniform(10,20,size=(2,3,2))
```
### 4. randn():
```py
	values from normal distribution with mean 0 and variance is 1

>>> np.random.randn(10)
>>> np.random.randn(2,3)
>>> np.random.randn(2,3,4)
```
### 5. normal():
```py
	We can customize mean and variance

	normal(loc=0.0, scale=1.0, size=None)

>>> np.random.normal(10,4,size=10)
>>> np.random.normal(10,4,size=(2,3,4))
```
### 6. shuffle():
```py
>>> help(np.random.shuffle)

## 1-D array:
>>> a = np.arange(9)
>>> a
>>> np.random.shuffle(a) #inline shuffling happens
>>> a

## 2-D array:
>>> a = np.random.randint(1,101,size=(6,5))
>>> a
>>> np.random.shuffle(a)
>>> a

## 3-D array:(4,3,4)
If we apply shuffle for 3-D array, then the order of 2-D arrays will be changed but not it's internal content

>>> a = np.arange(48).reshape(4,3,4)
>>> a
>>> np.random.shuffle(a)
>>> a
```
## Summary of random library functions:
* 1. randint() ==> To generate random int values in the given range.
* 2. rand() ==> To generate uniform distributed float values in [0,1)
* 3. uniform() ==> To generate uniform distributed float values in the given range.[low,high
* 4. randn() ==> normal distributed float values with mean 0 and standart deviation 1.
* 5. normal() ==> normal distributed float values with specified mean and standard deviation.
* 6. shuffle() ==> To shuffle order of elements in the given nd array.

## Array attributes:
* 1. ndim ===>returns the dimension of the array
* 2. shape===>returns the shape of the array.(10,):1-D, (10,3):2-D
* 3. size===>To get total number of elements.
* 4. dtype===>To get data type of elements of the array.
* 5. itemsize===>Length of each element of array in bytes(4-bytes)
```py
## Ex:
>>> a = np.array([10,20,30,40])
>>> a.ndim #1
>>> a.shape #(4,)
>>> a.size #4
>>> a.dtype #dtype('int32')
>>> a.itemsize #4

## Ex:
>>> a = np.array([[10,20,30],[40,50,60],[70,80,90]],dtype='float')
>>> a.ndim #2
>>> a.shape #(3, 3)
>>> a.size #9
>>> a.dtype #dtype('float64')
>>> a.itemsize #8
```
#### Day-4 https://youtu.be/TpozMOoNwoU

##### Day-5: 
# Numpy Data Types:

**Python data types:** int,float,str,complex,bool etc.......

**Numpy data types:** Multiple data types present(Python + C)

* i===>integer(int8,int16,int32,int64)
  ```py
  int8==>i1;
  int16==>i2;
  int32==>i4 (default)
  ```
* b===>boolean
* u===>unsigned integer(uint8,uint16,uint32,uint64)
* f===>float(float16,float32,float64)
  ```py
  float16==>f2;
  float32==>f4(default);
  float64==>f8
  ```
* c===>complex(complex64,complex128)
* s==>String
* U==>Unicode String
* M===>datetime etc.....

### int8:
-->The value will be represented by 8bits.  
-->MSB is reserved for sign  
-->The range:-128 to 127  
```py
import sys
import numpy as np
a = np.array([10,20,30,40])
print(sys.getsizeof(a))
a = np.array([10,20,30,40],dtype='int8')
print(sys.getsizeof(a))
```
## Changing the data type of an existing array
* 1) astype()
* 2) By using built-in function of numpy like float64()
```py
Ex:
import numpy as np
a = np.array([10,20,30,40])
b = a.astype('float64')
print(a.dtype)#int32
print(b.dtype)#float64

Ex:
a = np.array([10,20,30,40])
b = np.float64(a)
print(a.dtype)
print(b.dtype)

Ex:
a = np.array([10,0,30,0])
x = np.bool(a)#Invalid

x = np.bool_(a)
print(x)
```
## How to get/access elements of Numpy Array:
* 1. Indexing
* 2. Slicing
* 3. Advanced Indexing

### 1.Indexing:
By using index, we can get single element of the array.  
zero based indexing. i.e the index of first element is 0  
supports both +ve and -ve indexing  

```py
## From 1-D array:
a[index]
>>> a = np.array([10,20,30,40])
>>> a #array([10, 20, 30, 40])
>>> a[0] #10
>>> a[-1] #40
>>> a[10] #IndexError

## From 2-D array:
a[rowindex][columnindex]

>>> a = np.array([[10,20,30],[40,50,60]])
>>> a
array([[10, 20, 30],
       [40, 50, 60]])

## To Access 50
>>> a[1][1]
>>> a[1][-2]
>>> a[-1][-2]
>>> a[-1][1]

## From 3-D array:
(2,3,4)
	a[i][j][k]:
		i-->represents which 2-D array(index of 2-D array)
		j-->represents row index in that 2-D array
		k-->represents column index in that 2-D array

a[0][1][2]:
	0-indexed 2-D array
	In that 2-D array 1 indexed row and 2 indexed column

>>> l = [[[1,2,3],[4,5,6],[7,8,9]],[[10,11,12],[13,14,15],[16,17,18]]]
>>> a = np.array(l)
>>> a

## To access 14:
>>> a[1][1][1]
>>> a[-1][-2][-2]
>>> a[1][-2][-2]
>>> a[-1][1][-2]
```
### 2. Slicing : Accessing elements of ndarray by using slice operator:
a[begin:end:step]
```py
## 1-D array:
>>> a = np.arange(10,101,10)
>>> a
>>> a[2:5]
>>> a[::1]
>>> a[::-1]
>>> a[::-2]

## 2-D array:
a[row,column]
a[begin:end:step, begin:end:step]

>>> a = np.array([[10,20],[30,40],[50,60]])
>>> a
array([[10, 20],
       [30, 40],
       [50, 60]])

## Access [10, 20]
>>> a[0:1,:]

>>> a[0,:]
array([10, 20])#It is 1-D array

>>> a[0::2,:]
array([[10, 20],
       [50, 60]])

>>> a[0:2,1:2]
array([[20],
       [40]])

>>> a[:2,1:]
array([[20],
       [40]])

## Ex:
>>> a = np.array([[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]])
>>> a
array([[ 1,  2,  3,  4],
       [ 5,  6,  7,  8],
       [ 9, 10, 11, 12],
       [13, 14, 15, 16]])

>>> a[0:2,:]
array([[1, 2, 3, 4],
       [5, 6, 7, 8]])

>>> a[0::3,:]
array([[ 1,  2,  3,  4],
       [13, 14, 15, 16]])

>>> a[:,0:2]
array([[ 1,  2],
       [ 5,  6],
       [ 9, 10],
       [13, 14]])

>>> a[:,::2]
array([[ 1,  3],
       [ 5,  7],
       [ 9, 11],
       [13, 15]])

>>> a[1:3,1:3]
array([[ 6,  7],
       [10, 11]])

>>> a[::3,::3]
array([[ 1,  4],
       [13, 16]])
```
#### Day-5 https://youtu.be/N3mXkipScMU

##### Day-6 [28-02-2025]
Slice in 3-D array:
---
(2,3,4)  
(i,j,k)  

2 --> number of 2-D arrays  
3 --> the number of rows  
4 --> the number of columns  

	a[i,j,k]  
	a[begin:end:step,begin:end:step,begin:end:step]

```py
l = [[[1,2,3,4],
	[5,6,7,8],
	[9,10,11,12]],
	[[13,14,15,16],
	[17,18,19,20],
	[21,22,23,24]]]
>>> a = np.array(l)
>>> a
>>> a[:,:,0:1]
>>> a[:,0:1,:]
>>> a[:,::2,:]
>>> a[:,:2,1:3]
>>> a[:,::2,::3]
```
>[!Note]
>To use slice operator, compulsory elements should be in order. We cannot select elements which are out of order. i.e we cannot select arbitrary lements.  

## Advanced Indexing:

By using index, **we can access only one elment at a time**.  

	a[i], a[i][j], a[i][j][k]

By using slice operator **we can access multiple elements at a time**, but all elements should be in order.  

	a[begin:end:step]  
	a[begin:end:step,begin:end:step]  
	a[begin:end:step,begin:end:step,begin:end:step]  

## Accessing multiple arbitrary elements:

Access elements of 1-D array:
---

	1-D array:  
		array[x]:  
		x can be either nd array or list, which represents required indexes.


```py
>>> a = np.arange(10,101,10)
>>> a #array([ 10,  20,  30,  40,  50,  60,  70,  80,  90, 100])

Required values are:[30,50,60,90]
---------------------------------------------------
1st way:
------------
create ndarray with required indices
>>>>>> indices = np.array([2,4,5,8])

pass this indices array as argument to original array
>>> a[indices] #array([30, 50, 60, 90])

2nd way:
-------------
>>> l = [2,4,5,8]
>>> a[l] #array([30, 50, 60, 90])

values:[10,50,70,100]
---------------------------------
>>> a[[0,4,6,9]]

values:[10,100,50,70]
--------------------------------
>>> a[[0,9,4,6]]

values:[10,100]
-----------------------
>>> a[[0,-1]]
```
Access elements of 2-D array:
--------------------------------------------
```py
>>> l = [[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]]
>>> a = np.array(l)
>>> a

# I want to select:1,6,11,16
# Syntax:
#	a[[row_indices],[column_indices]]
#	a[[0,1,2,3],[0,1,2,3]]
#	It select elements from:(0,0),(1,1),(2,2) and (3,3)

>>> a[[0,1,2,3],[0,1,2,3]]
array([ 1,  6, 11, 16])

# Ex:To select:2,8,9,15
# ---------------------------------
>>> a[[0,1,2,3],[1,3,0,2]]

# L-Shape elements:
# ---------------------------
>>> a[[0,1,2,3,3,3,3],[0,0,0,0,1,2,3]]
array([ 1,  5,  9, 13, 14, 15, 16])
```

Accessing multiple arbitrary elements in 3-D array:
-----------------------------------------------------------------------------
```py
>>> a = np.arange(1,25).reshape(2,3,4)
>>> a

# Accessing 7 and 18 from the array

# Syntax:
#		a[[indices of 2d array],[row indices],[column indices]]
	
# Step-1:	7:						18:
#			i = 0					i = 1
#			j = 1					j = 1
#			k = 2					k = 1
#
#			i:[0,1]
#			j:[1,1]
#			k:[2,1]

>>>a[[0,1],[1,1],[2,1]]
array([ 7, 18])
```
Condition based selection:
---------------------------------------
We can select elements based on some condition also.
Syn:
>		array[boolean_array]
> In the boolean array, where ever True present the corresponding value will be selected.

```py
>>> a = np.array([10,20,30,40])
>>> boolean_array = np.array([True,False,False,True])
>>> a[boolean_array] #array([10, 40])

# select elements which are greater than 25
# ---------------------------------------------------------------
>>> b_a = a>25
>>> a[b_a]#array([30, 40])

>>> a[a>25]#array([30, 40])

Ex:
>>> a = np.array([10,-5,20,40,-3,-1,75])
>>> a #array([10, -5, 20, 40, -3, -1, 75])
>>> a[a < 0] #array([-5, -3, -1])
>>> a[a > 0] #array([10, 20, 40, 75])
>>> a[a%2 == 0] #array([10, 20, 40])
>>> a[a%5 == 0] #array([10, -5, 20, 40, 75])

# Condition based selection 2-D array also
# ------------------------------------------------------------
```py
>>> a = np.arange(1,26).reshape(5,5)
>>> a
>>> a[a%2 == 0]
>>> a[a%10 == 0]
```
## Slicing vs Advanced Indexing:

Python's Slicing:
---

In case of list, **slice operator will creates a separate copy**
If we perform **any changes in one copy those changes wont be reflected in other copy**.
```py
l1 = [10,20,30,40]
l2 = l1[:]
l2[1] = 333
l1[1] = 999
print(l1)
print(l2)
```
Numpy Array Slicing:
--------------------------------
**A separate copy wont be created and just we are getting view of the original copy**
```py
>>> a = np.arange(10,101,10)
>>> a
>>> b = a[0:4]
>>> b
>>> a[0] = 333
>>> a
>>> b
>>> b[1] = 999
>>> b
>>> a
```
##### Day-7 [1-03-2025]

Advanced Indexing and Condition Based selection:
---
	-->It will select required elements based on provided index or condition, and with those elements a new 1-D array object will be created.
	-->The output is always a new 1-D array only.

```py
>>> a = np.arange(10,101,10)
>>> a #array([ 10,  20,  30,  40,  50,  60,  70,  80,  90, 100])
>>> b = a[[0,2,5]]
>>> b #array([10, 30, 60])
>>> a[0] = 333
>>> a #array([333,  20,  30,  40,  50,  60,  70,  80,  90, 100])
>>> b #array([10, 30, 60])
>>> b[0]=999
>>> b #array([999,  30,  60])
>>> a #array([333,  20,  30,  40,  50,  60,  70,  80,  90, 100])
```
Slicing vs Advanced Indexing
--------------------------------------------
	Slicing:
		-->The elements should be ordered.
		-->We can't select arbitrary elements.
		-->Conditional based selection is not possible.
		-->Just we will get View but not copy.
		-->Memory, performance-wise it is the best.

	Advanced Indexing:
		-->The elements need not be ordered.
		-->We can select arbitrary elements
		-->Condition based selection is possible.
		-->Just we will get separate copy but not view.
		-->Memory, performance-wise not up to the mark

Summary of syntaxes:
---------------------------------
Basic Indexing:
-----------------------
	1-D array: a[i]
	2-D array: a[i][j] or a[i,j]
	3-D array: a[i][j][k] or a[i,j,k]

Slicing:
-----------
	1-D array: a[begin:end:step]
	2-D array: a[begin:end:step,begin:end:step]
	3-D array: a[begin:end:step,begin:end:step,begin:end:step]

Advanced Indexing:
-----------------------------
	1-D array: a[x]-->x contains ndarray or list
	2-D array: a[[row_indices],[column_indices]]
	3-D array: a[[indices of 2D array],[row_indices],[column_indices]]

Condition based selection:
----------------------------------------
	a[condition]==>a[a>0]
	This is same for all 1-D,2-D and 3-D arrays

## How to iterate elements of the ndarray:

Iteration means getting all elements one-by-one
--
	3-ways:
		1.By using python's loops
		2.By using nditer() function
		3.By using ndenumerate() function  


1 : By using python's loops
---

To iterate elements of 1-D array
-----------------------------------------------
```py
import numpy as np
a = np.arange(10,51,10)
for x in a:
	print(x)
```
To iterate elements of 2-D array
-----------------------------------------------
```py
import numpy as np
a = np.array([[10,20,30],[40,50,60],[70,80,90]])
for x in a:#x is 1-D array but not scalar value
	for y in x:#y is a scalar value present in 1-D array
		print(y)
```
To iterate elements of 3-D array
------------------------------------------------
```py
import numpy as np
a = np.array([[[10,20],[30,40]],[[50,60],[70,80]]])
for x in a:#x is 2-D array but not scalar value
	for y in x:#y is 1-D array but not scalar value
		for z in y:#z is a scalar value
			print(z)
```
> [!Note]
> To iterate elements of n-D array, we required n-loops.

2 : By using numpy's nditer()
---------------------------------------
> [!Note]
> Advantage: For any n-D array only one loop is enough.

	nditer is a class present in numpy module.
	nditer() ---> Creating an object of inditer class.

1-D array:
---------------
```py
import numpy as np
a = np.arange(10,51,10)
for x in np.nditer(a):
	print(x)
```
2-D array:
---------------
```py
a = np.array([[10,20,30],[40,50,60],[70,80,90]])
for x in np.nditer(a):
	print(x)
```
3-D array:
---------------
```
a = np.array([[[10,20],[30,40]],[[50,60],[70,80]]])
for x in np.nditer(a):
	print(x)
```
Iterate elements of slicied array:
------------------------------------------------
```py
import numpy as np
a = np.array([[10,20,30],[40,50,60],[70,80,90]])
for x in np.nditer(a[:,:2]):
	print(x)
```
Using nditer() to get elements of required data type:
------------------------------------------------------------------------------
```py
# We have to use op_dtypes
>>>help(np.nditer)

a = np.array([[10,20,30],[40,50,60],[70,80,90]])
for x in np.nditer(a,flags=['buffered'],op_dtypes=['float']):
	print(x)
print(a)
```
Normal Python loops vs nditer():
------------------------------------------------

| Python loops | nditer |
|:--------------|:--------------|
| **n-loops** are required.|Only **one loop** is enough.| 
| Can not specify our required **dtype**. | Can specify required **dtype** by using **op_dtypes** argument.  |


##### Day-8 [3-03-2025]

3: By using ndenumerate() function
----------------------------------------------------
	If we want to find co-ordinates also in addition to element.
	array indices(coordinates) and values

1-D array
-------------------
```py
import numpy as np
a = np.array([10,20,30,40,50])
for pos,element in np.ndenumerate(a):
	print(f'{element} element present at index/position:{pos}')
```
2-D array:
---------------
```py
a = np.array([[10,20,30],[40,50,60],[70,80,90]])
for pos,element in np.ndenumerate(a):
	print(f'{element} element present at index/position:{pos}')
```
3-D array:
---------------
```py
a = np.arange(1,25).reshape(2,3,4)
for pos,element in np.ndenumerate(a):
	print(f'{element} element present at index/position:{pos}')
```
## Arithmetic operators:

		+, -, *, /, **, //

1-D array:
---------------
```py
>>> a = np.array([10,20,30,40])
>>> a #array([10, 20, 30, 40])
>>> a+2 #array([12, 22, 32, 42])
>>> a-2 #array([ 8, 18, 28, 38])
>>> a*2 #array([20, 40, 60, 80])
>>> a%2 #array([0, 0, 0, 0], dtype=int32)
>>> a/2 #array([ 5., 10., 15., 20.])
>>> a//2 #array([ 5, 10, 15, 20], dtype=int32)
```
2-D array:
--------------
```py
>>> a = np.array([[10,20,30],[40,50,60]])
>>> a
>>> a+2
>>> a-2
>>> a*2
>>> a**2
>>> a/2
>>> a//2
```

>[!Note]
>In python anything by zero including zero/zero results is : **ZeroDivisionError**
>
>But in Numpy there is **no ZeroDivisionError.**  
>10/0==>Infinity(inf)  
>0/0==>undefined(nan-->not a number)

Ex:
```py
>>> a = np.arange(6)
>>> a/0 #array([nan, inf, inf, inf, inf, inf])
```
Arithmetic operators for Arrays with Arrays:
------------------------------------------------------------------
	Compulsory both arrays should have:  
		--> Same dimension  
		--> Same shape and
		--> Same size
	-->otherwise we will get error.

1-D array:
---------------
```py
>>> a = np.array([1,2,3,4])
>>> b = np.array([10,20,30,40])
>>> a.ndim
>>> b.ndim
>>> a.shape
>>> b.shape
>>> a.size
>>> b.size
>>> a+b
>>> a-b
>>> a*b
>>> b/a
>>> b//a
```
2-D array
-------------
```py
>>> a = np.array([[1,2],[3,4]])
>>> b = np.array([[5,6],[7,8]])
>>> a+b
>>> a-b
>>> a*b
>>> b/a
>>> b//a
```
When shape is not same.  
Ex:
```py
>>> a = np.array([10,20,30])
>>> b = np.array([10,20,30,40])
>>> a+b
ValueError: operands could not be broadcast together with shapes (3,) (4,)
```
Equivalent numpy library function for arithmetic operators :
------------------------------------------------------------------------------------
universal function (ufunc) in the NumPy library that performs **element-wise addition of two arrays or a scalar and an array.**
```py
>>> a = np.array([10,20,30])
>>> b = np.array([1,2,3])
>>> np.add(a,b)
>>> np.subtract(a,b)
>>> np.multiply(a,b)
>>> np.divide(a,b)
>>> np.floor_divide(a,b)
>>> np.mod(a,b)
>>> np.power(a,b)
```
>[!Note]
>The functions which operates element by element on whole array are called as Universal functions(ufunc).

Broadcasting:
--------------------

>Eventhough **dimensions are different**, **shapes are different** and **sizes are different** **still some arithmetic operations are allowed by Broadcasting**.

>[!Note]
>Broadcasting will be **performed automatically by numpy itself** and we are not required to perform explicitly.

Rules for Broadcasting:
-----------------------------------
Rule-1:
-------
	Make sure both arrays should have same dimension  
	Padded(Add) 1's in the shape of lesser dimension array on the left side, until both arrays have same dimension.

	Before:
		(4,3)--->2-D
		(3,)---->1-D

	After:
		(4,3)--->2-D
		(1,3)--->2-D

Rule-2:
----------
	If the size of 2-arrays does not match in any dimension,
	then the arrays with size equal to 1 in that dimension will be increased to the size of other dimension to match.

	Note:
		If any dimension, the sizes are not matched and neither equal to 1,
		then we will get an error, Numpy does not able to perform broadcasting between those arrays.

	Before:
		(4,3)-->2-D
		(1,3)-->2-D

	Afetr:
		(4,3)-->2-D
		(4,3)-->2-D

	-->Now dimensions, shapes and size are equal.

Ex-2:
--------
```py
Broadcasting between (3,2,2) and (3,) possible or not
Before Rule-1:
	(3,2,2)
	(3,)
After Rule-1:
	(3,2,2)
	(1,1,3)

After Rule-2:
	(3,2,2)
	(3,2,3)

same dimension, but different shapes, so numpy unable to perform broacasting.

Note:
	The data will be reused from the same input array
	If the rows are required then re-use existing row
	If the columns are required then re-use existing columns
	The result is always higher dimension of input arrays
	input:3-D,1-D
	output:3-D

>>> a = np.array([10,20,30])	--->1-D	shape(3,)
>>> b = np.array([40])				--->1-D	shape(1,)
>>> a+b
array([50, 60, 70])	
```
Ex:
```py
>>> a = np.array([[10,20],[30,40],[50,60]])		--->2-D	shape(3,2)
>>> b = np.array([10,20])					-->1-D	shape(2,)
>>> a+b
array([[20, 40],
       [40, 60],
       [60, 80]])
```
Ex:
```py
>>> a = np.array([[10],[20],[30]])		-->2-D	shape(3,1)
>>> b = np.array([10,20,30])		-->1-D	shape(3,)
>>> a+b
array([[20, 30, 40],
       [30, 40, 50],
       [40, 50, 60]])
```

## Array Manipulation functions:
* 1.reshape()
* 2.resize()
* 3.flatten()
* 4.flat variable
* 5.ravel()
* 6.transpose()
* 7.swapaxes()

##### Day-9 [4-03-2025]

1.reshape():
----
	shape to another shape
	(10,)--->(5,2),(2,5),(10,1),(1,10)
	(24,)--->(3,8)-->(2,3,4),(6,4),(2,2,2,3)

1).The **data remian same** shoud not be changed and **input size and output size** must be matched .

Ex:
```py
>>> import numpy as np
>>> a = np.arange(10)
>>> a
>>> a.ndim #1
>>> a.shape #(10,)
>>> b = np.reshape(a,(5,2))
>>> b
>>> b = np.reshape(a,(10,1))
>>> b
>>> b = np.reshape(a,(1,5,2))#3-D array 5-rows and 2-columns
>>> b
```
Ex:
```py
>>> a = np.arange(24)
>>> a
>>> b = np.reshape(a,(6,4))
>>> b
>>> b = np.reshape(a,(2,3,4))
>>> b
>>> b = np.reshape(a,(6,5))
ValueError: cannot reshape array of size 24 into shape (6,5)
```
2).No change in the data.  
**New array object won't be created.**  
Just we are getting view of existing object,**view but not copy.**  
If we perform any **changes in the original array, that change will be reflected to reshaped array**. Viceversa.
```py
>>> a = np.arange(12)
>>> a
>>> b = np.reshape(a,(4,3))
>>> b
>>> a[0] = 333
>>> a
>>> b
>>> b[1][1] = 999
>>> b
>>> a
```
3). we can specify **unknown dimension size as -1.**

Ex:
```py
# a = (12,)
# b = (6,-1)===>(6,2)

>>> a = np.arange(12)
>>> b = np.reshape(a,(6,2))
>>> b
>>> b = np.reshape(a,(6,-1))
>>> b
>>> b = np.reshape(a,(-1,3))
>>> b
>>> b = np.reshape(a,(-1,-1))#Error

>>> a = np.arange(24)
>>> b = np.reshape(a,(2,3,-1))
>>> b = np.reshape(a,(2,-1,4))
>>> b = np.reshape(a,(-1,3,4))
>>> b = np.reshape(a,(3,4,-1))
>>> b = np.reshape(a,(5,-1))#Error
```
4).
```py
help(np.reshape)  
		reshape(a, newshape, order='C')
```
C style -->**Row major order**  
Fortran style --->**Column major order**

```py
>>> a = np.arange(12).reshape(3,4)
>>> a
>>> b = np.reshape(a,(12,),'C')
>>> b #array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11])
>>> b = np.reshape(a,(12,),'F')
>>> b #array([ 0,  4,  8,  1,  5,  9,  2,  6, 10,  3,  7, 11])
```
Ex:
```py
>>> a = np.arange(24,)
>>> a
>>> np.reshape(a,(6,4),'C')
>>> np.reshape(a,(6,4),'F')
```
Conclusion:
-----------------
>[!Note]
>1.To reshape array without changing data.  
>2.The size must be matched.  
>3.We can use either numpy library function or ndarray class method  
>				np.reshape()  
>				a.reshape()  
>4.It wont create a new array object, just we will get view.  
>5.We can use -1 in unknown dimension, but only once.  
>6.Order:'C','F'  

2).resize():
---------------
>[!Note]
>output array: can be any dimension, any shape, any size

	1).Input size and output size need not be matched.
	2).The data may be changed
	3).We will get copy but not view
	4).How to get that new data
			np.resize()--->repeat elements of input array
			a.resize()--->use zero for extra elements
	5). -1 such type of story not applicable for resize()
			input:(10,)
			reshape:(5,-1)
			resize:(5,-1)
	6).If we use ndarray class resize() method, inline modification will be happended.

Ex:
```py
>>> a = np.arange(1,6)
>>> a
>>> b = np.resize(a,(4,3))
>>> b
>>> a[0] = 333
>>> a
>>> b
>>> b[0][1]=999
>>> b
>>> a
>>> refcheck=False
>>> a = np.arange(1,6)
>>> a.resize(5,3)
>>> a
```

Q.Difference between np.resize() and ndarray.resize()?
------------------------------------------------------

| np.resize()     | ndarray.resize() |
|:----------------|:-----------------|
| 1). It is library function in numpy module. | 1). It is method present in ndarray class|
| 2). It will create new array and returned it.| 2). It wont return new array and existing array will be modified.|
|3). If the newshape required more elements then repeated copies of original array will be reused.|3). Extra elements filled with zeros. |

Q.Differences between reshape() and resize()?
-----------------------------------------------

| reshape()     | resize() |
|:----------------|:-----------------|
|1.It is just to reshape to array without changing size and data.|1.It is to resize() array, data may be changes, size may be changed.|
|2.Just view will be created but not copy,if we perform any change in the original array,automatically those changes will be reflected in reshaped copy also. |2.Separate copy will be created. If we perform any changes in the original array those changes wont be reflected in 	resize array.|
|3.We can use -1 in unknown dimension.|3.There is no story like -1.|



##### Day-10 [5-03-2025]

3: flatten():
-----------------

* convert any **n-D(1-D,2-D,3-D,n-D) array to 1-D array**.  
* It is **method present in ndarray class** but not numpy library function.  
	- **a.flatten() ==> valid**  
	- **np.flatten() ==> invalid**  
* a.flatten(**order='C'**)  
	- C-style ==> row major order  
	- F-style ==> column major order  
*  It will **create a new copy and returns it**(i.e copy but not view).  
*  The output of the flatten method is **always 1-D array**.  

Ex:
-----
```py
>>> a = np.arange(6).reshape(3,2)
>>> a
>>> a.flatten()
>>> a.flatten('F')
>>> b = a.flatten()
>>> a[0][0] = 3113
>>> a
>>> b
>>> b[1] = 999
>>> b
>>> a
```
Ex:
```py
>>> a = np.arange(1,19).reshape(3,3,2)
>>> a
>>> b=a.flatten()
>>> a.ndim #3
>>> b.ndim #1
>>> b
```
4: flat variable:
----------------------
It is a **1-D iterator over the array.**  
This is a **'numpy.flatiter' instance.**  

```py
>>> a = np.arange(1,19).reshape(3,3,2)
>>> a
>>> a.flat[2] #3
>>> a.flat[10] #11
>>> for x in a.flat:print(x)

>>> help(np.flatiter)
```
5: ravel()
--------------
* Convert any **n-D array to 1-D array**  
* It is **method present in ndarray class and also numpy library function**  
	* a.ravel() ==> valid  
	* np.ravel() ==> valid  
* a.ravel(**order='C'|'F'**)  
	- C-style ==> row major order  
	- F-style ==> column major order  
* It returns **view but not copy**.  
* The output of ravel method is **always 1-D array**.  

```py
>>> help(np.ravel)
>>> help(np.ndarray.ravel)
```
Ex:
```py
>>> a = np.arange(24).reshape(2,3,4)
>>> a
>>> b = a.ravel()
>>> b
>>> b[0] = 333
>>> b
>>> a
>>> a = np.arange(18).reshape(6,3)
>>> a
>>> b = np.ravel(a)
>>> b
```
Q.Difference between flatten() and ravel()?
--------------------------------------------------------------

|flatten()|ravel()|
|:-------|:---------|
|1. To convert any **n-D array to 1-D array and a new array object will be created**. |1. To convert any **n-D array to 1-D array but returns just view but not copy**.|
|2. If we perform any changes in the flatten copy, then those **changes wont be reflected in the original copy**.| 2. If we perform any **changes in the ravel copy, then those changes will be reflected in the original copy**.|
|3. It is **ndarray class method** but not numpy library function.|3. We can use as **method and as well as a function**.|


6: transpose() :
---------------------
```py
>>> help(np.transpose)

	transpose(a, axes=None)
    Reverse or permute the axes of an array; returns the modified array.
Ex:
>>> a = np.arange(1,5).reshape(2,2)
>>> a
>>> b = np.transpose(a)
>>> b

## Note:No change in data hence it returns only view but not copy

>>> a[0][0] = 333
>>> a
>>> b
```
for 3-D array :
---------------------
	(2,3,4)
	2---> 2-D arrays
	3---> 3 rows
	4---> 4 columns
	total size = 24

	transpose(a, axes=None)

	transpose(a) ==> (4,3,2)

```py
>>> a = np.arange(24).reshape(2,3,4)
>>> a
>>> b = np.transpose(a)
>>> b
>>> b.shape #(4, 3, 2)
```
Transpose of 1-D array:
-----------------------------------
Transpose of **1-D array will be generated same array only**

```py
>>> a = np.arange(6)
>>> a
>>> np.transpose(a)
```
Transpose 4-D array :
---------------
a = (2,3,4,5)  
np.transpose(a) ----> (5,4,3,2)

axes parameter:
-------------------------
* If we are **not using axes** parameter, then **dimension will be reversed**.  
* axes parameter tells in which order it has to take axes.  
* It is very helpful for 3-D and 4-D arrays.  

	for 3-D array : (2,3,4)

	The size of axis-0: 2
	The size of axis-1: 3
	The size of axis-2: 4

	np.transpose(a) ----> (4,3,2)

	My required order is:(2,4,3)/(4,2,3)/(3,4,2)
	np.transpose(a,axes=(0,2,1))/(2,0,1)/(1,2,0)

Ex:
----
```py
>>> a = np.arange(24).reshape(2,3,4)
>>> a
>>> a.shape #(2, 3, 4)
>>> b = np.transpose(a,axes=(0,2,1))
>>> b.shape #(2, 4, 3)
>>> b = np.transpose(a,axes=(2,0,1))
>>> b.shape #(4, 2, 3)
>>> b = np.transpose(a,axes=(1,2,0))
>>> b.shape #(3, 4, 2)
>>> np.transpose(a,axes=(0,2,2))#ValueError: repeated axis in transpose
```

>[!Note]
>* 1. For **1-D array, there is no impact of transpose() function**.  
>* 2. If we are **not using axes argument**, then **dimensions will be reversed**.  
>* 3. If we **provide axes argument**, then we can **specify our own order axes**.  
>* 4. Repeated axis in transpose is **not allowed**(0,2,2).  
>* 5. axes argument is more helpful from **3-D array onwards** but not for 2-array.  
>* 6. Various possible syntaxes:  
>		- np.transpose(a)  
>		- np.transpose(a,axes=(2,0,1))  
>		- ndarray.transpose()  
>		- ndarray.T  
>		- ndarray.transpose(*axes)  

ndarray class transpose() method:
------------
```py
>>> help(np.ndarray.transpose)
		a.transpose(*axes)
		Returns a view of the array with axes transposed.

>>> a = np.arange(24).reshape(2,3,4)
>>> a.shape #(2, 3, 4)
>>> b = a.transpose()
>>> b.shape #(4, 3, 2)
>>> b = a.transpose((2,0,1))
>>> b.shape #(4, 2, 3)
>>> b = a.T 
>>> b.shape #(4, 3, 2)
```
##### Day-11 [6-03-2025]

swapaxes():
--------
input:(2,3,4) :  
output:(4,3,2)/(3,2,4)/(2,4,3)/(3,4,2) etc......

By transpose() function, we can interchange any number of dimensions.  
But if want to **interchange only two dimensions** then we should go for swapaxes().

swapaxes(a, axis1, axis2) --> Interchange two axes of an array.

a = (2,3,4)  
np.swapaxes(a,0,2) ---> (4,3,2)  
np.swapaxes(a,1,2) ---> (2,4,3)  

Ex:
```py
>>> a = np.arange(24).reshape(2,3,4)
>>> a
>>> a.shape #(2, 3, 4)
>>> b = np.swapaxes(a,0,2)
>>> b.shape #(4, 3, 2)
>>> b = np.swapaxes(a,1,2)
>>> b.shape #(2, 4, 3)
```
ndarray class also contains swapaxes:
-----------------------------------
```py
>>> help(np.ndarray.swapaxes)
	    a.swapaxes(axis1, axis2)
	    Return a view of the array with `axis1` and `axis2` interchanged.

>>> a.shape #(2, 3, 4)
>>> b = a.swapaxes(0,1)
>>> b.shape #(3, 2, 4)
```
Q. Difference between transpose() and swapaxes()?
----------------------------------------------
By using transpose() we can **interchange any number of dimensions**.  
By using swapaxes() we can **interchange only two dimensions**.  

Joining of multiple ndarrays into a single array
=========================================
It is something similar to line join queries in Oracle.

* 1. concatenate()
* 2. stact()
* 3. vstack()
* 4. hstack()
* 5. dstack()

1: concatenate()
-----------------------
```py
>>> help(np.concatenate)

concatenate((a1, a2, ...), axis=0, out=None, dtype=None, casting="same_kind")
Join a sequence of arrays along an existing axis.
```
2-D array + 2-D array
--------------------------------
* axis=0(default): **vertical** concatenation will happens  
* axis=1: **Horizontal** concatenation will happens  
* axis=**None**  

**These 2-D arrays will be flatten to 1-D array and then concatenation will happens**

```py
>>> a = np.array([[1,2],[3,4]])
>>> b = np.array([[5,6],[7,8]])
>>> a
>>> b
>>> np.concatenate((a,b))
>>> np.concatenate((a,b),axis=0)
>>> np.concatenate((a,b),axis=1)
>>> np.concatenate((a,b),axis=None)
```
Rules :
---------
1.We can **join any number of arrays**, but all arrays **should be same dimension**.  
2.The size of **all axes must be matched,except concatenation axes.**  
	(2,3) 
	(5,3)  
3.The result of concatenation and output have the same shape.  

Concatenation of two 1-D arrays:
-------------------------------
Ex-1
```py
>>> a = np.arange(4)
>>> a
>>> b = np.arange(5)
>>> b
>>> np.concatenate((a,b))
>>> c = np.arange(3)
>>> c
>>> np.concatenate((a,b,c))

# Storing result out parameter

>>> d = np.zeros(12,dtype=int)
>>> d
>>> np.concatenate((a,b,c),out=d)
>>> d
>>> d = np.empty(12,dtype=int)
>>> np.concatenate((a,b,c),out=d)
>>> d

# Using dtype parameter:
# We can specify the required type by using dtype parameter

>>> np.concatenate((a,b,c),dtype='float')
>>> np.concatenate((a,b,c),dtype='str')

#Note:
#	We cannot use dtype and out simultaneously, because out array has its own dtype.

>>> c = np.empty(9)
>>> np.concatenate((a,b),out=c,dtype='int')
TypeError: concatenate() only takes `out` or `dtype` as an argument, but both were provided.
```
Joining of 2-D arrays :
---------------------
* For 2-D array the existing axes are:  
	* axis-0 ---> Represents the **number of rows**  
	* axis-1 ---> Represents **number of columns**  

* We can perform concatenation based on **either axis-0 or axis-1.**
* The **size of all dimensions(axes) must be matched except concatenation axis.**  
* If we are not specifying axis the **default value is 0.**  
* If axis is None, **then arrays will be flatten to 1-D array** and then **concatenation will be happend.**

Ex-1
```py
>>> a = np.array([[10,20],[30,40],[50,60]])
>>> b = np.array([[70,80],[90,100]])
>>> a
>>> np.concatenate((a,b))
>>> np.concatenate((a,b),axis=1)#Invalid
>>> np.concatenate((a,b),axis=None)
```
Ex-2:
```py
>>> a = np.arange(6).reshape(3,2)
>>> a.shape #(3, 2)
>>> b = np.arange(9).reshape(3,3)
>>> b.shape #(3, 3)
>>> np.concatenate((a,b),axis=0) #Not possible
>>> np.concatenate((a,b),axis=1)
>>> np.concatenate((a,b),axis=None)
```

Concatenation of 3-D arrays :
-----------------------------
(x,y,z)

* axis-0-->The number of **2-D array**
* axis-1-->The number of **rows in every 2-D array**
* axis-2-->The number of **columns in every 2-D array**

Ex-1:  
a = (2,2,2)
b = (2,2,2)

```py
>>> a = np.arange(8).reshape(2,2,2)
>>> b = np.arange(8).reshape(2,2,2)
>>> np.concatenate((a,b),axis=0)
>>> np.concatenate((a,b),axis=1)
>>> np.concatenate((a,b),axis=None)
```
Ex-2:

	a = (2,3,2)
	b = (2,3,3)

	axis-0--->no  
	axis-1--->no  
	axis-2---yes  

	Q. a:(2,3,3) and b:(1,3,3)  
	axis-0 only possible

	Q. (3,2,3) and (2,1,3)
	Not possible to perform concatenation on any axis
	But axis=None is possible

##### Day-12 [7-03-2025]

Joining of multiple arrays by using stack() function:
-----------------------------------------------------
1-D + 1-D --->2-D  
2-D + 2-D --->3-D

	Rules:
		The input array must have same shape.
		The resultant stacked array has one more dimension than the input array
		Joining will happen along new axis of newly created array.

Stacking of 1-D array:
----------------------
```py
>>> a = np.array([10,20,30])
>>> b = np.array([40,50,60,70])
>>> np.stack(a,b) #Invalid

>>> a = np.array([10,20,30])
>>> b = np.array([40,50,60])
>>> np.stack((a,b))
>>> np.stack((a,b),axis=0)
>>> np.stack((a,b),axis=1)
```
stacking of 2-D array:
---------------------
```py
# The resultant array will be : 3-D array
# 3-D array shape:(x,y,z)
# x--->axis-0
# y--->axis-1
# z--->axis-2

>>> a = np.array([[1,2,3],[4,5,6]])
>>> b = np.array([[7,8,9],[10,11,12]])
>>> np.stack((a,b),axis=0)
>>> np.stack((a,b),axis=1)
>>> np.stack((a,b),axis=2)

Ex:
>>> a = np.arange(1,7).reshape(3,2)
>>> b = np.arange(7,13).reshape(3,2)
>>> c = np.arange(13,19).reshape(3,2)
>>> np.stack((a,b,c),axis=0)Q.What i
>>> np.stack((a,b,c),axis=1)
>>> np.stack((a,b,c),axis=2)
```
Stacking Three 1-D array
------------------------
```py
>>> a = np.arange(4)
>>> b = np.arange(4,8)
>>> c = np.arange(8,12)
>>> np.stack((a,b,c),axis=0)
>>> np.stack((a,b,c),axis=1)
```
Q. What is the difference between concatenate() and stack()?
---

|Feature |numpy.concatenate()|numpy.stack()|
|:-----------|:--------|:---------|
|Dimensionality|The output array has the **same number of dimensions** as the input arrays.|The output array has **one more dimension** than the input arrays.|
|Input Shape|Input arrays must have the **same shape, except for the axis you are joining on**.|All input arrays **must have the exact same shape**.|
|Joining Behavior|Combines arrays by appending their data to one another along a specified axis.|Joins arrays by introducing a new axis and placing the input arrays along that axis.|

3.vstack():
----------------
vstack ---> vertical stack ---> joining is **always based on axis-0**  
For 1-D arrays ----> 2-D array is output.  
For 1-D array the **size must be same**.  
The result of vstack() function should be atleast 2-D.  

Ex-1

```py
>>> a = np.array([10,20,30,40])
>>> b = np.array([50,60,70,80])
>>> np.vstack((a,b))
```
Ex-2
```py
>>> a = np.arange(1,10).reshape(3,3)
>>> b = np.arange(10,16).reshape(2,3)
>>> a
>>> b
>>> np.vstack((a,b))
```
Ex:
```py
>>> a = np.arange(1,10).reshape(3,3)
>>> b = np.arange(10,16).reshape(3,2)
>>> np.vstack((a,b))#Not possible
```
For 3-D arrays:
---------------
**axis-0 means the number of 2-D arrays**
```py
>>> a = np.arange(1,25).reshape(2,3,4)
>>> b = np.arange(25,49).reshape(2,3,4)
>>> np.vstack((a,b))
```
Joining of arrays by using hstack() function:
---------------------------------------------
hstack ---> horizontal stack ----> column wise  
1-D + 1-D ---> 1-D

For 1-D array:
--------------
```py
>>> a = np.array([10,20,30])
>>> b = np.array([40,50,60])
>>> np.hstack((a,b))
array([10, 20, 30, 40, 50, 60])
```
For -2D array:
--------------
```py
>>> a = np.arange(1,7).reshape(3,2)
>>> b = np.arange(7,16).reshape(3,3)
>>> np.hstack((a,b))

>>> a = np.arange(1,7).reshape(2,3)
>>> b = np.arange(7,16).reshape(3,3)
>>> np.hstack((a,b))#not possible
```
joining of arrays by using dstack():
-------------------------------------
dstcak means ---> depth stack / height stack **based on axis-2.**  
1-D and 2-D arrays will be converted to 3-D array.  
The result **is minimum 3-D array**

Ex:
```py
>>> a = np.array([1,2,3])
>>> b = np.array([2,3,4])
>>> np.dstack((a,b))
```
Ex:
```py
>>> a = np.array([[1],[2],[3]])
>>> b = np.array([[2],[3],[4]])
>>> np.dstack((a,b))
```
Summary of joining nd arrays:
------------------------------
>[!Note]  
1.concatenate() ==> Join a sequence of arrays **along existing axis**.  
2.stack() ==> Join a sequence of arrays **along a new axis**.  
3.vstack() ==> Stack arrays in sequence **vertically according to axis-0**.  
4.hstack() ==> Stack arrays in sequence **horizontally according to axis-1**.  
5.dstack() ==> Stack arrays in sequence **depth wise according to axis-2**.  

Splitting of ndarrays:
----------------------
- 1). split()
- 2). vsplit()
- 3). hsplit()
- 4). dsplit()
- 5). array_split()

**Above methods returns views but not copies.**

1). split():
-----------
```py
>>> help(np.split)
split(ary, indices_or_sections, axis=0)
    Split an array into multiple sub-arrays as views into `ary`.
```
sections:  
	1.Array will be splitted into **sub arrays of equal size**.  
	2.It returns list of sub arrays.  

To split 1-D array into 3-parts
-------------------------------
```py
>>> a = np.arange(1,10)
>>> np.split(a,3)
>>> sub_arrays = np.split(a,3)
>>> sub_arrays[0] #array([1, 2, 3])
>>> sub_arrays[1] #array([4, 5, 6])
>>> sub_arrays[2] #array([7, 8, 9])
>>> sub_arrays = np.split(a,4)#array split does not result in an equal division
```
Splitting of 2-D array:
-----------------------
splitting is based on **axis-0 by default**. i.e row wise split **(vertical split)**  
we can also split based on **axis-1**. i.e column wise split **(horozintal split)**

Splitting based on axis-0 [ vertical split (default split) ] :
--------------------------

```py
>>> a = np.arange(1,25).reshape(6,4)
>>> a
>>> np.split(a,3)
>>> np.split(a,2)
>>> np.split(a,6)
>>> np.split(a,4)#Not possible
```
Splitting based on axis-1 [horizonatal split]:
--------------------------
axis-1 means column wise splitting (horizontal split).

```py
>>> a = np.arange(1,25).reshape(6,4)
>>> np.split(a,2,axis=1)
>>> np.split(a,4,axis=1)
>>> np.split(a,3,axis=1)#Not possible
```


------
>[!Note]
>Numpy Sum Explanation other sources link  
>ToDo -- move to apporoprita location, where numpy sum is explained.  
>[Numpy Sum explanation](https://medium.com/data-science/understanding-numpy-sum-1587eec69527)
------

##### Day-13 [8-03-2025]

Splitting based on indices:
----------------------------
The sizesof sub arrays **need not be equal**.

Ex:
```py
>>> a = np.arange(10,101,10)
>>> a 
>>> np.split(a,[3,7])
>>> np.split(a,[2,5,7])
```
Split 2-D array based on indices:
---------------------------------
```py
>>> a = np.arange(1,13).reshape(6,2)
>>> a
>>> np.split(a,[3,4])
>>> np.split(a,[1,3,4])

>>> a = np.arange(1,19).reshape(3,6)
>>> a
>>> np.split(a,[1,3,5],axis=1)
>>> np.split(a,[2,4,4],axis=1)
>>> np.split(a,[0,2,6],axis=1)
>>> np.split(a,[1,5,3],axis=1)
```
Splitting by using vsplit():
----------------------------
vsplit means vertical split **means row wise split**, is based on axis-0.  
To use vsplit, input array should be **atleast 2-D array**.
```py
>>> help(np.vsplit)
		vsplit(ary, indices_or_sections)

# To use vsplit, input array should be atleast 2-D array.

>>> a = np.arange(10)
>>> a
>>> np.vsplit(a,2)
ValueError: vsplit only works on arrays of 2 or more dimensions
```
vsplit - For 2-D array:
--------------
```py
>>> a = np.arange(1,13).reshape(6,2)
>>> a
>>> np.vsplit(a,2)
>>> np.vsplit(a,3)
>>> np.vsplit(a,6)
>>> np.vsplit(a,[1,4]) #base on indices
```
Splitting by using hsplit():
----------------------
split horizontally(column wise)
```py
>>> a = np.arange(10)
>>> a
>>> np.hsplit(a,2)
>>> np.hsplit(a,5)
>>> np.hsplit(a,3)#Error
```
hsplit - For 2-D array:
--------------
Based on axis-1 only
```py
>>> a = np.arange(1,13).reshape(3,4)
>>> a
>>> np.hsplit(a,2)
>>> np.hsplit(a,4)
>>> np.hsplit(a,3)#Error
```
hsplit based on indices:
------------------------
```py
>>> a = np.arange(10,101,10)
>>> a
>>> np.hsplit(a,[2,4,7])

>>> a = np.arange(24).reshape(4,6)
>>> a
>>> np.hsplit(a,[2,4])
>>> np.hsplit(a,[1,4])
```
>[!Note]
> - vsplit() ---> split based on **axis-0(row)**
> - hsplit() ---> split based on **axis-1(column)**
> - dsplit() ---> split based on **axis-2 ---> 3-D array**

Splitting using dsplit():
-------------------------
```py
>>> help(np.dsplit)
		dsplit(ary, indices_or_sections)
			Split array into multiple sub-arrays along the 3rd axis (depth).

>>> a = np.arange(24).reshape(2,3,4)
>>> a
>>> np.dsplit(a,2)
>>> np.dsplit(a,[1,3]) # dsplit based on indices
```

##### Day-14 [10-03-2025]

Split using array_split():
------------------------
The numpy.array_split() function splits an array into multiple sub-arrays along a specified axis.  

Its main advantage over the standard numpy.split() is that it **allows for uneven divisions without raising an error**.

array_split()  -->  sections **need not be to have equal size** 

split() with sections ---> **Should be equal parts**, otherwise ---> error 

4 --> rows ----> 3 equal parts

```py
>>help(np.array_split()
array_split(ary, indices_or_sections, axis=0)
    Split an array into multiple sub-arrays.
```
For an array of length **x** that should be split into **n** sections,  
It returns 
- **x % n sub-arrays of size (x//n)+1** 
- **and rest of size x//n**

```py
#Ex-1
# 10 elements ---> 3 sections  

#	x = 10		n = 3  

# x % n number of sub-arrays of size : (x//n)+1 ===> 1 number of sub-array of size: 4  

# rest of size x//n ==> 2 number of sub-arrays of size : 3  


>>> a = np.arange(10,101,10)
>>> a
>>> np.array_split(a,3)

#Ex-2
# 11 elements ---> 3 sections 

#	11-elements			3-sections

# x % n number of sub-arrays of size : (x//n)+1 ===> 2 sub-array of size : 4
# rest of size x//n==>1 sub-arrays of size : 3

(4,4,3)

>>> a = np.arange(0,101,10)
>>> a
>>> np.array_split(a,3)
```
Summary of split methods:
-------------------------
>[!Note]
> - split() : Split an array into multiple sub-arrays of **equal size**.  
> - vsplit() : Split an array into multiple sub-arrays **vertically(row wise).**  
> - hsplit() : Split an array into multiple sub-arrays **horizontally(column wise).**  
> - dsplit() : Split an array into multiple sub-arrays along the **3rd axis(depth).**  
> - array_split() : Split an array into multiple sub-arrays of equal or near-equal size & **Does not raise an exception** if an equal division cannot be made.  

Sorting of ndarrays:
--------------------
```py
>>> help(np.sort)
			quicksort    -->merge sort ,heap sort
```
The default is **'quicksort'**  
For numbers --> **Ascending order**  
For strings ---> **Alphabatical order**  

1-D array
------------
```py
>>> a = np.array([20,10,5,40,30,50])
>>> a
>>> np.sort(a)
```
To sort in descending order
---------------------------
```py
# 1st way:
	>>> np.sort(a)[::-1]

# 2nd way:
	>>> a
	>>> -a
	>>> np.sort(-a)
	>>> -np.sort(-a)
```
To sort string elements in alphabatical order:
------------------------------------------
```py
>>> a = np.array(['sunny','bunny','vinny','chinny'])
>>> np.sort(a)
```
To sort reverse of alphabatical order:
--------------------------------------
```py
>>> np.sort(a)[::-1]
>>> -np.sort(-a) #Invalid
```
for 2-D array:
--------------
```py
>>> a = np.array([[40,20,70],[30,20,60],[70,90,80]])
>>> a
>>> np.sort(a,axis=0)
>>> np.sort(a,axis=-2)
```
Searching elements of ndarray using where():
------------------------------

where() function returns indices where condition is True, and does not returns elements.

```py
>>>help(np.where)
	where(...)
    where(condition, [x, y])

>>> a = np.array([3,5,7,6,9,4,6,10,15])
>>> a
```
Find indices where the value is 7
```py
>>> np.where(a==7)
```

Find indices where odd numbers present in array
```py
>>> np.where(a%2!=0)
```
To get elements directly
```py
>>>indices = np.where(a%2!=0)
>>>a[indices]
```
condition based selection using where():
----
where function can perform replace operation also.
>where(condition, [x, y]):  

If **condition satisfied that element will be replaced with x** and if the **condition fails that element will be replaced with y.**

Ex:
```py
>>> a
array([ 3,  5,  7,  6,  9,  4,  6, 10, 15])

# Replace even numbers with 333 and every odd number with 999
>>> np.where(a%2==0,333,999)
```
Replace odd numbers present in a (ndarray) with 333.
```py
>>> np.where(a%2!=0,333) #Invalid
>>> np.where(a%2!=0,333,a)
```
For 2-D array
-------------
```py
>>> a = np.arange(12).reshape(4,3)
>>> a
>>> np.where(a%5==0)
(array([0, 1, 3], dtype=int64), array([0, 2, 1], dtype=int64))
# The first ndarray represents row indices and second ndarray represents column indices.
# i.e required elements present at ((0,0),(1,2) and (3,1) index places.

# If we want to see the elements

>>> b = np.where(a%5==0)
>>> a[b]

# Even we can perform replacement operation also

>>> np.where(a%5==0,999,a)
```
searchsorted() function:
-----------------------
**Find indices** where elements should be inserted to maintain order.  
Internally this function uses **use binary search algorithm**.  
Hence we **can call this function only for sorted arrays**.  
If the array is not sorted then we will get abnormal results.
```py
searchsorted(a, v, side='left', sorter=None)
    Find indices where elements should be inserted to maintain order.

>>> a = np.arange(0,31,5)
>>> a
>>> np.searchsorted(a,5) #1
>>> np.searchsorted(a,13) #3
```

By default it will **always search from left hand side** to identify insertion point.  
If we want to search from right hand side we should use **side = 'right'.**

```py
>>> a = np.array([3,5,7,6,7,9,4,10,15,6])
>>> a = np.sort(a)
>>> a
>>> np.searchsorted(a,6)#3
>>> np.searchsorted(a,6,side='right') #5
```

>[!Note]
> - sort() ---> To sort given array.
> - where() ---> To perform search and replace operation.
> - searchsorted() ---> To identify insertion point in the given sorted array.


##### Day-15 [11-03-2025]

How to insert elements into ndarray?
------------------------------------
1. insert()  
2. append()

1.insert()
----------

The numpy.insert() function inserts **values into an array before a given index** and along a specified axis. It returns a **new array** and does not modify the **original array in-place**. 

```py
>>> help(np.insert)
insert(arr, obj, values, axis=None)
    Insert values along the given axis before the given indices.
```

- arr : The input array.
- obj : The index or indices before which values will be inserted. This can be a single integer, a slice object, or an array of indices.
- values : The value or array of values to be inserted. It can be a scalar or an array-like object.
- axis : The axis along which to insert the values. If axis is not specified, the input array is flattened before insertion. 


Inserting into 1-D 
------------------
```py
>>> a = np.arange(10)
>>> a
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
```
To insert 999 before index 2
```py
np.insert(a,2,999)
```
To insert 999 before index 2 and 5?
```py
np.insert(a,[2,5],999)
```
To insert 999 before index 2 and 333 before index 5
```py
np.insert(a,[2,5],[999,333])
```

```py
# Valid use
>>>np.insert(a,[2,5],[999,333,666])#Invalid
>>>np.insert(a,[2,5,7],[999,333])#Inva>>>lid
>>>np.insert(a,[2,5,5],[999,333,666])#>>>Valid
>>>np.insert(a,20,333)#IndexError
```


- Array should contain **only homogenious elements**.  
- If we are trying to insert any **other type element**, that **element will be converted to array type automatically before insertion**.   
- If the conversion **not possible then we will get an error**.

```py
>>> a
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
>>> np.insert(a,2,12.34)
>>> np.insert(a,2,True)
>>> np.insert(a,2,'sunny') #Invalid
```
>[!Note]
> while inserting elements into 1-D array:  
>	1.The **number of indices and the number of elements** should be matched.  
>	2.**Out of range index** is not allowed.  
>	3.Elements will be **converted automatically to the array type**.  

Inserting elements into 2-D array:
----------------------------------
We should provide axis.  
If we are not providing axis, then **default value None**, will be considered.  
Then the array will be **flatten to 1-D array** and then insertion will be happened.

Ex:
```py
>>> a = np.array([[10,20],[30,40]])
>>> a
>>> np.insert(a,1,100)
array([ 10, 100,  20,  30,  40])

>>> np.insert(a,1,[100,200],axis=0)
>>> np.insert(a,1,[100,200],axis=1)
>>> np.insert(a,1,100,axis=0)
>>> np.insert(a,1,100,axis=1)

# In 2-D array axis-0 means rows(axis:-2)
# In 2-D array axis-1 means columns(axis:-1)

>>> np.insert(a,0,[100,200],axis=-1)
```
Appending elements to ndarray by using append():
------------------------------------------------
insert() ---> To insert **element at our required position.**  
append() ---> To insert **element at last**.  

```py
	append(arr, values, axis=None)
		Append values to the end of an array.

>>> a = np.arange(10)
>>> a
>>> np.append(a,333)
>>> np.append(a,[10,20,30])

# Note:
# If we are trying to append hetrogenious element,
# then array elements and new element will be converted to some common type,
# and then append will be happened.

>>> np.append(a,10.5)
>>> np.append(a,'sunny')
>>> np.append(a,True)
>>> np.append(a,10+3j)
```
Appending elements to 2-D array:
-------------------------------
- We should provide axis, otherwise **None will be considered and flatten to 1-D array** before append operation.

- If we are providing axis, then all input arrays must have **same number of dimensions and same shape** of provided axis.
```py
>>> a = np.array([[10,20],[30,40]])
>>> a
>>> np.append(a,70) #array([10, 20, 30, 40, 70])
>>> np.append(a,70,axis=0)#Invalid
>>> np.append(a,[70,80],axis=0)#Invalid
>>> np.append(a,[[70,80]],axis=0)
>>> np.append(a,[[70,80],[50,60]],axis=0)
>>> np.append(a,[[70,80]],axis=1)#Invalid
>>> np.append(a,[[70],[80]],axis=1)
>>> np.append(a,[[70,80],[50,60]],axis=1)
```
Q.Consider the query?
---------------------
```py
>>> a = np.arange(12).reshape(4,3)
>>> a
array([[ 0,  1,  2],
       [ 3,  4,  5],
       [ 6,  7,  8],
       [ 9, 10, 11]])

# Which of the following operations will be performed successfully ?
# ----------------------------------------------------------------
# A. np.append(a,[[10,20,30]],axis=0)#Valid
# B. np.append(a,[[10,20,30]],axis=1)#Invalid
# C. np.append(a,[[10],[20],[30]],axis=0)#Invalid
# D. np.append(a,[[10],[20],[30],[40]],axis=1)#Valid
# E. np.append(a,[[10,20,30],[40,50,60]],axis=0)#Valid
# F. np.append(a,[[10,20],[30,40],[50,60],[70,80]],axis=1)#Valid
```


##### Day-16 [12-03-2025]

Q.What is the difference between insert() and append() function?
----------------------------------------------------------------

|Feature|numpy.insert()|numpy.append()|
|:-----------|:------------|:-------------|
|Insertion Location|Inserts values at a specific index that you specify.|Appends values to the end of the array.|
|Arguments|Requires an index or set of indices (obj) to specify the insertion point.|Does not require an index, as it always operates at the end of the array.|
|Usage|Use when you need to insert an element or array of elements somewhere other than the end of the array.|Use when you want to add an element or array of elements to the end of an array.|
|Effect on Array|Creates and returns a new array. Shifts existing elements to make room for the new values.|Creates and returns a new array. Simply adds the new values after the existing elements.|
|Performance|Can be less performant for very large arrays because it requires shifting all subsequent elements, especially if you insert at the beginning.|Generally more efficient than insert() for adding elements because it avoids shifting existing data.|
|axis=None Behavior|Flattens only the input array (arr) before inserting values, which means the values parameter must be broadcastable to the new shape.|Flattens both the input array and the appended values (arr and values) before performing the operation.|

Deletion of elements from ndarray:
----------------------------------
The numpy.delete() function removes elements from an array at specified indices and returns a new array.  
It **does not modify the original array in-place**. This is because NumPy arrays **have a fixed size**, and resizing them requires creating a new array in a different memory location. 

```py
>>> help(np.delete)
delete(arr, obj, axis=None)
```

To delete elements of 1-D array:
--------------------------------
```py
>>> a = np.arange(10,101,10)
>>> a
>>> np.delete(a,3)
>>> np.delete(a,[0,4,6])
>>> np.delete(a,np.s_[2:6])
>>> np.delete(a,np.s_[:])
>>> np.delete(a,range(2,6))
```
To delete elements of 2-D array:
--------------------------------
We should provide axis. If we are not providing axis, then array will be **flatten to 1-D array** and then delete will be happened.

```py
>>> a = np.arange(1,13).reshape(3,4)
>>> a
>>> np.delete(a,1)
>>> np.delete(a,1,axis=0)
>>> np.delete(a,1,axis=0)
>>> np.delete(a,[0,2],axis=0)
>>> np.delete(a,np.s_[:2],axis=0)
```
Delete by column wise
```py
>>> np.delete(a,0,axis=1)
>>> np.delete(a,[0,2],axis=1)
>>> np.delete(a,np.s_[::2],axis=1)
>>> np.delete(a,np.s_[1::3],axis=1)
>>> np.delete(a,np.s_[1:],axis=1)
```
Delete elements from 3-D array:
------------------------------
- axis-0: **index of 2-D array**
- axis-1: **Rows in every 2-D array**
- axis-2: **Columns in every 2-D array**
```py
>>> a = np.arange(24).reshape(2,3,4)
>>> a
>>> np.delete(a,3) #flatten to 1-D array and delete 3rd index element
>>> np.delete(a,0,axis=0)#1st 2-D array deleted
>>> np.delete(a,1,axis=0)#2nd 2-D array deleted
>>> np.delete(a,1,axis=1)
		To delete 1st indexed row in every 2-D array
>>> np.delete(a,2,axis=2)
		To delete 2nd indexed column in every 2-D array
>>> np.delete(a,[0,2],axis=2)
>>> np.delete(a,np.s_[1:],axis=2)
```
Ex -
```py
>>> a = np.arange(12).reshape(4,3)
>>> a
array([[ 0,  1,  2],
       [ 3,  4,  5],
       [ 6,  7,  8],
       [ 9, 10, 11]])

# Replace last row with [70,80,90]
# delete last row and insert required row.

>>> b = np.delete(a,3,axis=0)
>>> b
>>> np.append(a,[[70,80,90]],axis=0)
```
Matrix multiplication by using dot() function
---------------------------------------------
ndarrays : a and b

a * b ---> element level multiplication will happen.
```py
>>> a = np.array([[10,20],[30,40]])
>>> a
>>> b = np.array([[1,2],[3,4]])
>>> b
>>> a*b
array([[ 10,  40],
       [ 90, 160]])
```
For matrix multiplication, should use **dot()** function.
```py
>>> np.dot(a,b)
array([[ 70, 100],
       [150, 220]])

# A.B===>a.dot(b)
>>> a.dot(b)
```
Importance of matrix class in numpy library
-------------------------------------------
1-D array is called  ---> **Vector**  
2-D array is called  ---> **Matrix**

matrix class is specially designed class to create 2-D arrays

How to create 2-D array:  
- By using ndarray
- By using matrix class
```py
>>> help(np.matrix)
class matrix(ndarray)
   matrix(data, dtype=None, copy=True)
```
Creating matrix object from string:  
a = np.matrix('col1 col2 col3;col1 col2 col3')  
a = np.matrix('col1,col2,col3;col1,col2,col3')  

```py
>>> a = np.matrix('10,20;30,40')
>>> type(a)#<class 'numpy.matrix'>
>>> a = np.matrix('10 20;30 40')
>>> type(a) #<class 'numpy.matrix'>
```

create a matrix from nested list
```py
>>> a = np.matrix([[10,20],[30,40]])
>>> a
```
create a matrix from ndarray
```py
>>> a = np.arange(6).reshape(3,2)
>>> type(a) #<class 'numpy.ndarray'>
>>> b = np.matrix(a)
>>> type(b) #<class 'numpy.matrix'>
```
addition '+' operator in ndarray and matrix:  
In both case **ndarray and matrix** + (addition) operator behaves in the same way.
Ex:
```py
a = np.array([[1,2],[3,4]])
b = np.matrix([[1,2],[3,4]])
a + a
m + m
```
Multiplication '*' operator in ndarray and matrix:
- In case of ndarray * (Multiplication) operator performs element level multiplication.
- In case of matrix * (Multiplication) operator performs matrix multiplication.

```py
>>> a*a
array([[ 1,  4],
       [ 9, 16]])

>>> m*m
matrix([[ 7, 10],
        [15, 22]])
```
Raise to the power '**' operator in ndarray and matrix:
- In case of ndarray ** operator performs power operation at element level
- In case of matrix ** performs power operation at matrix level m**2 ==> m*m
```py
>>> a**2
array([[ 1,  4],
       [ 9, 16]])

>>> m**2
matrix([[ 7, 10],
        [15, 22]])
```

Transpose in ndarray and matrix:
In case of both **ndarray and matrix T behaves in the same way**.
```py
>>> a.T
array([[1, 3],
       [2, 4]])

>>> m.T
matrix([[1, 3],
        [2, 4]])
```
Q.Differences between ndarray and matrix?
----------------------------------------------------------------
|ndarray                          |matrix                                  |
|:--------------------------------|:---------------------------------------|
|1. It can represent any **n-dimension array**.|1. It can be represents **only 2-D array**|
|2. We can create from array_like object but **not from string**.|2. We can create from **either array_like object or from string**.|
|3. * operator meant for **element multiplication** but not for dot product.|3. * operator meant for **dot product** but not for element multiplication.|
|4. ** meant for **element level power operation**|4. ** meant for **matrix power operation**.|
|5. It is the **parent class**.|5. It is **child class** of numpy.ndarray.|
|6. It is **recommended to use**.|6. It is **not recommended to use and it is deprecated**.|

##### Day-17 [13-03-2025]

Linear Algebra functions from 'linalg' module
-------------------------------------------
1. inv() ---> To find inverse of a matrix.
2. matrix_power() --> To find power of matrix like A power(n).
3. det() ---> To find determinant of a matrix.
4. solve() --> To solve linear algebra equations.


1). Inverse of matrix 'np.linalg.inv()'
----

A * A.inverse = Identity matrix

```py
>>> help(np.linalg.inv)
    Compute the (multiplicative) inverse of a matrix.
```		
Given a square matrix 'a', return the matrix 'ainv' satisfying **dot(a, ainv) = dot(ainv, a) = eye(a.shape[0])**.
Ex:
```py
>>> a = np.array([[1,2],[3,4]])
>>> a	
>>> ainv = np.linalg.inv(a)
>>> ainv
```
How to check
```py
>>> i = np.eye(2)
>>> i
>>> np.dot(a,ainv)
>>> np.allclose(i,np.dot(a,ainv))
True
```
We can find **inverse only for a square matrices**, otherwise we will get an error.

Ex:
```py
>>> a = np.array([[10,20,30],[40,50,60]])
>>> np.linalg.inv(a)#Invalid
```
How to find inverse of 3-D array:
--------------------------------
3-D array contains collection of 2-D arrays.  
Finding inverse of 3-D array means, **finding inverse of every 2-D array**.
```py
>>> a = np.arange(8).reshape(2,2,2)
>>> a
>>> np.linalg.inv(a)
```
2). Power of matrix 'np.linalg.matrix_power()' :
--------------------------
```py
matrix_power(a, n)
    Raise a square matrix to the (integer) power 'n'.
```
- if n == 0 ===> Identity matrix
- if n > 0 ===> Normal power operation
- if n < 0 ===> First inverse and then power operation for absolute value

Ex:
```py
>>> a = np.array([[1,2],[3,4]])
>>> a
>>> np.linalg.matrix_power(a,0)
>>> np.linalg.matrix_power(a,2)
>>> np.linalg.matrix_power(a,-2)
>>> np.dot(np.linalg.inv(a),np.linalg.inv(a))
>>> np.linalg.matrix_power(np.linalg.inv(a),2)
```
We can find **matrix_power only for a square matrices**.

```py
>>> a = np.arange(10).reshape(5,2)
>>> a
>>> np.linalg.matrix_power(a,2)#Invalid
```
3). Determinant of a matrix 'np.linalg.det()' :
-----------
We can find **determinant only for square matrices**.

```py
Syn: det(a) ===> ad-bc

>>> a = np.array([[1,2],[3,4]])
>>> a
>>> np.linalg.det(a)
-2.0000000000000004
```
For 3X3 matrix :
```py
>>> a = np.arange(9).reshape(3,3)
>>> a
array([[0, 1, 2],
       [3, 4, 5],
       [6, 7, 8]])
>>> np.linalg.det(a)
0.0
```

4). solve linear algebra equations 'np.linalg.solve()'
---------------------------------------------------

	solve(a, b)
		Solve a linear matrix equation, or system of linear scalar equations.

	Parameters
	----------
		a : (..., M, M) array_like
			Coefficient matrix.
		b : {(..., M,), (..., M, K)}, array_like
			Ordinate or "dependent variable" values.

Case Study / Ex:
```
boys + girls = 2200
boys:3$
girls:8$
Total fees:10100$

x + y = 2200  =====> x = 2200-y
3x + 8y = 10100

3(2200-y) + 8y = 10100
6600 - 3y + 8y = 10100
5y = 10100 - 6600
5y = 3500
y = 700
x = 1500
```
```py
# A = 1  1
#     3  8

# B = [2200,10100]

>>> a = np.array([[1,1],[3,8]])
>>> b = np.array([2200,10100]
>>> np.linalg.solve(a,b)
array([1500.,  700.])
```
Ex:
```py
# -4x+7y-2z = 2
# x-2y+z = 3
# 2x-3y+z = -4

a = np.array([[-4,7,-2],[1,-2,1],[2,-3,1]])
b = np.array([2,3,-4])

>>> np.linalg.solve(a,b)
array([-13.,  -6.,   4.])
```
I/O Operations with Numpy
------------------------

We can **save / write ndarray objects to a binary file** for future purpose.  
Later point of time, whenever these objects are required, we **can read from that binary file**.

- save() ---> To **save / write** ndarray object to a file.
- load() ---> To **read** ndarray object from a file.
```py
save(file, arr, allow_pickle=True, fix_imports=True)
    Save an array to a binary file in NumPy '.npy' format.

load(file, mmap_mode=None, allow_pickle=False, fix_imports=True, encoding='ASCII')
    Load arrays or pickled objects from '.npy', '.npz' or pickled files.
```
Ex: **Saving ndarray object to a file and read from the file**
```py
import numpy as np
a = np.array([[10,20,30],[40,50,60]])
#save/serialize ndarray object to a file
np.save('out.npy',a)
#load/deserialize ndarray object form a file
out_array = np.load('out.npy')
print(out_array)
```


##### Day-18 [17-03-2025]


1. The data will be **stored in binary form**.
2. File extension should be **'.npy'**, otherwise save() function itself add that extension.
3. By using **save() function can write only one object** to the file.
4. To write multiple objects to a file then we should go for **savez() function** and file extention is **.npz**.

Saving multiple ndarray objects to the binary file
```py
import numpy as np
a = np.array([[10,20,30],[40,50,60]])
b = np.array([[70,80],[90,100]])
np.savez('out.npz',a,b)
npzfileobj = np.load('out.npz')
print(type(npzfileobj))
print(npzfileobj.files)
print(npzfileobj['arr_0'])
print(npzfileobj['arr_1'])
```
- **np.save()** ---> Save an array to a binary file in .npy format.
- **np.savez()** ---> Save several arrays into a single file in .npz format but in uncompressed form.
- **np.savez_compressed()** ---> Save several arrays into a single file .npz format but in compressed form.
- **np.load()** ---> To load/read arrays from .npy or .npz files.

compressed form:
```py
np.savez_compressed('out_compressed.npz',a,b)
npzfileobj = np.load('out_compressed.npz')
```
Q. We can save object in compressed form, then what is the need of uncompressed form?
- compressed form ===> **memory will be saved, but performance down**.
- uncompressed form ===> **memory wont be saved, but performance wise good**.

Save ndarray objects to the file in normal text format
-------------------------------------------------------
- savetxt()
- loadtxt()
```py
>>> help(savetxt)
savetxt(fname, X, fmt='%.18e', delimiter=' ', newline='\n', header='', footer='', comments='# ', encoding=None)   
Save an array to a text file.

>>> help(np.loadtxt)
loadtxt(fname, dtype=<class 'float'>, comments='#', delimiter=None, converters=None, skiprows=0, usecols=None, unpack=False, ndmin=0, encoding='bytes', max_rows=None, *, like=None)
Load data from a text file.
```
Ex:
```py
import numpy as np
a = np.array([[10,20,30],[40,50,60]])
#np.savetxt('out.txt',a)
np.savetxt('out.txt',a,fmt='%.1f')
out_array1 = np.loadtxt('out.txt')
print(out_array1)
out_array2 = np.loadtxt('out.txt',dtype='int')
print(out_array2)
```
Ex:
```py
import numpy as np
a1 = np.array([['Sunny',1000],['Bunny',2000],['Vinny',3000]])
#np.savetxt('out.txt',a1)#Error
np.savetxt('out.txt',a1,fmt='%s %s')
#a2 = np.loadtxt('out.txt')#Error bcoz bydefault considered float
a2 = np.loadtxt('out.txt',dtype='str')
print(a2)
```
Writting ndarray objects to the csv file
----------------------------------------
csv ---> Comma Separated Values
```py
import numpy as np
a1 = np.array([[10,20,30],[40,50,60]])
np.savetxt('out.csv',a1,delimiter=',')
a2 = np.loadtxt('out.csv',delimiter=',')
print(a2)
```
>[!Note]
> 1. Save one ndarray object to the binary file --> save() & load()
> 2. Save multiple ndarray objects to the binary file in uncompressed form --> savez() & load()
> 3. Save multiple ndarray objects to the binary file in compressed form --> savez_compressed() & load()
> 4. Save ndarray object to the text file --> savetxt() & loadtxt()
> 5. Save ndarray object to the csv file --> savetxt() & loadtxt() with delimiter=','

Basic statics with numpy
------------------------
1. Minimum value
2. Max value
3. Average value
4. Sum of all values
5. Mean value
6. Median value
7. Variance
8. Standard deviation etc...

1.Minimum value:
----------------
**np.min(a) & np.amin(a)** --> funtionality identical  
np.min() is an alias for np.amin(), so their functionality is identical.

**a.min()**  --> A method of the NumPy ndarray object.

```py
>>> help(np.min)

min(a, axis=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>)
    Return the minimum of an array or minimum along an axis.
```
In n-dimension of an array. If we are not providing axis, then it will be **converted to 1-D array** and returns minimum value.

```py
>>> a = np.array([10,5,20,3,25])
>>> np.min(a) #3
>>> np.amin(a)#3
>>> a.min()#3
>>> a.amin()#Error
```
2-D array
---------
```py
>>> a = np.array([[100,20,30],[10,50,60],[25,15,18],[4,5,19]])
>>> a
>>> np.min(a)#4
>>> np.min(a,axis=0)#returns minimum row that row contains 3-elements
array([ 4,  5, 18])
>>> np.min(a,axis=1)#returns minimum column and that col contains 4-elements
array([20, 10, 15,  4])
```
Ex:
```py
>>> a = np.arange(24).reshape(6,4)
>>> a
>>> np.min(a) #0
>>> np.min(a,axis=0) #array([0, 1, 2, 3])
>>> np.min(a,axis=1) #array([ 0,  4,  8, 12, 16, 20])
```
Ex:
```py
>>> a = np.arange(24)
>>> a
>>> np.random.shuffle(a)
>>> a
>>> a = a.reshape(6,4)
>>> a
>>> np.min(a)#0
>>> np.min(a,axis=0)
>>> np.min(a,axis=1)
```


##### Day-19 [18-03-2025]


2). Finding max value:
--------------------
np.max(a)  
np.amax(a)  
a.max()  

Ex:
```py
>>> a = np.arange(24)
>>> np.random.shuffle(a)
>>> a = a.reshape(6,4)
>>> a
>>> np.max(a)#23
>>> np.max(a,axis=0)
>>> np.max(a,axis=1)
>>> a.max()#23
>>> np.amax(a)#23
```
2-D array
--------
```py
a = np.array([[100,20,30],[10,50,60],[25,15,18],[4,5,19]])
>>> a
>>> np.max(a) #100
>>> np.max(a,axis=0) #array([100,  50,  60])
>>> np.max(a,axis=1) #array([100,  60,  25,  19])
```
3). Finding sum of values:
------------------------
np.sum(a)  
a.sum()
```py
>>> a = np.arange(4)
>>> a #array([0, 1, 2, 3])
>>> np.sum(a) #6
>>> a.sum() #6
```
2-D array
--------

```py
>>> a = np.arange(9).reshape(3,3)
>>> a
>>> np.sum(a)#36
>>> a.sum()#36
>>> np.sum(a,axis=0)#array([ 9, 12, 15])
>>> np.sum(a,axis=1)#array([ 3, 12, 21])
```
4). Finding Mean value:
----------------------
np.mean(a)  
a.mean()

Mean is the sum of elements along the specified axis divided by number of elements.

```py
>>> a = np.arange(5)
>>> a #array([0, 1, 2, 3, 4])
>>> np.mean(a) #2.0
>>> a.mean() #2.0
```
2-D array:
---
```py
>>> a = np.arange(9).reshape(3,3)
>>> a
>>> np.mean(a)#4.0
>>> np.mean(a,axis=0)#array([3., 4., 5.])
>>> np.mean(a,axis=1)#array([1., 4., 7.])
```
5). Finding median value :
-----------------

np.median(a)  

Mean means average.  
Median means **middle element of the array**.

10 20 30 ---> 20  
10 20 30 40 --> 25.0 (Avg/Mean of middle 2-elements)

```py
>>> a = np.array([10,20,30])
>>> np.median(a)#20.0
>>> a.median()#Error
>>> a = np.array([10,20,30,40])
>>> np.median(a)#25.0
```
2-D array:
---
```py
>>> a = np.arange(9).reshape(3,3)
>>> a
>>> np.median(a)#4.0
>>> np.median(a,axis=0)#array([3., 4., 5.])
>>> np.median(a,axis=1)#array([1., 4., 7.])
```
Finding variance of the ndarray:
-------------------------------
np.var(a)  
a.var()

It is calculated by taking the average of squared deviations from the mean.  

average   
sqaured  
deviation from the mean  

1-D array:
---------------
a = [1,2,3,4,5]

mean(a) = 3.0  
Deviation from the mean:[-2.0,-1.0,0.0,1.0,2.0]  
Squares of deviation from the mean:[4.0,1.0,0.0,1.0,4.0]  
Average of squares of deviation from mean : 2.0 ===> Variance

```py
>>> a = np.array([1,2,3,4,5])
>>> np.var(a) #2.0
```

Finding standard deviation by using numpy std() function
--------------------------------------------------------
Standard deviation is the square root of the variance.  
Variance means the average of squares of deviation from the mean.

1-D array:
---------------
```py
>>> a = np.array([1,2,3,4,5])
>>> np.var(a)#2.0
>>> np.std(a)#1.4142135623730951
>>> a.std()#1.4142135623730951
```
Summary:
----------------
1. **np.min(a)/np.amin(a)/a.min()** --> Returns the minimum value of the array.
2. **np.max(a)/np.amax(a)/a.max()** --> Returns the maximum value of the array.
3. **np.sum(a)/a.sum()** --> Returns the sum of values of the array.
4. **np.mean(a)/a.mean()** --> Returns the arithmetic mean of the array.
5. **np.median(a)** -->Returns median value of the array.
6. **np.var(a)/a.var()** -->Returns variance of the values in the array.
7. **np.std(a)/a.std()** -->Returns standard deviation of the values in the array.

Numpy Mathematical Functions:
-----------------------------
The functions which operates **element by element on whole array**, are called **universal functions.(ufunc)**

1. np.exp(a) ---> Takes e to the power of each value. e value : 2.7182
2. np.sqrt(a)
3. np.log(a)
4. np.sin(a)
5. np.cos(a)
6. np.tan(a)

```py
>>> a = np.arange(5)
>>> a
>>> np.exp(a)
>>> np.sqrt(a)
>>> np.log(a)
>>> np.sin(a)
>>> np.cos(a)
>>> np.tan(a)
```

How to find unique items and count
----------------------------------
```py
>>> help(np.unique)
unique(ar, return_index=False, return_inverse=False, return_counts=False, axis=None)
    Find the unique elements of an array.
```
To get array with unique values
```py
>>> a = np.array([1,1,2,3,4,2,3,4,4,1,2,3,4,5,5,6])
>>> np.unique(a)
array([1, 2, 3, 4, 5, 6])
```
To get indices also
```py
>>> items,indices = np.unique(a,return_index=True)
>>> items
>>> indices
>>> a[indices]
```

To get the count:
```py
>>> items,counts = np.unique(a,return_counts=True)
>>> items
>>> counts
```
Creation of array by using diag() function:
-----------------------------------------
```py
>>> help(np.diag)
diag(v, k=0)
    Extract a diagonal or construct a diagonal array.

>>> a = np.arange(1,10).reshape(3,3)
>>> a
>>> np.diag(a,k=0)#array([1, 5, 9])
>>> np.diag(a,k=1)#array([2, 6])
>>> np.diag(a,k=2)#array([3])
>>> np.diag(a,k=-1)#array([4, 8])
>>> np.diag(a,k=-2)#array([7])
>>> np.diag(a,k=-3)#array([], dtype=int32)
```
Ex:
```py
>>> a = np.array([10,20,30,40])
>>> a
>>> np.diag(a,k=0)
>>> np.diag(a,k=1)
>>> np.diag(a,k=2)
>>> np.diag(a,k=-1)
```

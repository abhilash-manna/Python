# Day-1
## Python for Data Science, ML, DL and AI:
Devopps-->Regular core python knowledge
			concise code
			Rich libraries--->70 to 90% our libraries 10% we have to write the code.

What is this line in python?
			import numpy as np

Numpy-->Entry point from  python for DS
Numpy-->Numerical Python Library

## How to install Numpy?
>>>pip install numpy

## How to check version:
D:\Mahesh_Classes>py
>>> import numpy as np
>>> np.__version__

## What is the need of Numpy?
Python performs basic mathematical operations.
a = 10
b = 20
a+b
a-b
a/b
a*b

math.sqrt(4)

But in Data Science, ML, DL and AI required complex matghematical operations....

1.Numpy defines several functions to perform complex mathematical operations.
2.To fullfill performance gaps
	most of the Numpy is implemented in C-Language
	superfast
3.nd array(To store large data in nd array for matplotlib graph style)
	-->n dimensional array or numpy array

Ex:
	matrix with all zero 10X10 shape
	l = [[0,0,0,0...],[],[],......[]]

>>>import numpy as np
>>>a = np.zeros((10,10))
>>>a

If you want only int type:
	>>> a = np.zeros((10,10),dtype=int)

list of 100-numbers:
	>>>a = np.arange(1,101)
	>>>a

pls convert into 2-dimension array
>>>a.reshape(10,10)

Identity matrix?
>>>a = np.identity(3)
>>>a = np.identity(5)

4.Data Analysis:
		2 crore samples are analyzed
		100 -->points
		new patient--->corona

## History of Numpy:
Origin of Numpy---->Numeric Library
Numeric Library--->Jim Hugunin
Numpy-->Travis Oliphant(2005)
Open source library and freeware

Q.In which language Numpy was written?
C and Python

## Q.What is nd array in numpy?
The fundamental data type to store our data:nd array

>>> a = np.identity(5)
>>> type(a) #<class 'numpy.ndarray'>
>>> help(np.ndarray)
Help on class ndarray in module numpy:

arrays are objects of ndarray class present in numpy module

Array:An indexed collection of homogenious elements

1-D array	--->Vector
2-D array	--->Matrix
.
.
.
n-D array	--->No name

## Day-2:
# Day-1 https://youtu.be/z2Hq-8-fWrY

Numpy Basic Introduction
Array Creation:
	10+ ways are

>>> np.ones((2,3))
array([[1., 1., 1.],
       [1., 1., 1.]])

>>> np.ones((10))
array([1., 1., 1., 1., 1., 1., 1., 1., 1., 1.])

Attributes
How to access elements of array
	Basic Indexing
	Slice Operations
	Advanced Indexing
	Condition Based Selection

Ex:
>>> a = np.arange(1,21)
>>> a
>>> a[a%6==0]
array([ 6, 12, 18])

How to iterate elements of an array:
	python's normal loops
	nditer()
	ndenumerate()

Arithmetic operators
Broadcasting
Array Manipulation functions
	reshape()
	resize()
	flatten()
	ravel()
	transpose()
	etc....
Matrix class

## Ex:What is the need of Numpy
Boys and Girls are attending Mahesh sir datascience class.
For boys fee is $3 and for girls fees is $8, For a certain batch 2200 people attended and $10100 fee collected. How many boys and girls attended for that batch.

x --->no of boys
y --->no of girls

x + y = 2200
3x + 8y = 10100

coefficient matrix:
a =	1 1
		3 8
value matrix
	b = [2200,10100]

numpy.linalg.solve(a,b)

>>> import numpy as np
>>> a = np.array([[1,1],[3,8]])
>>> a
array([[1, 1],
       [3, 8]])
>>> b = np.array([2200,10100])
>>> b
array([ 2200, 10100])
>>> np.linalg.solve(a,b)
array([1500.,  700.])

## Array:
An indexed collection of homogenious data elements.

## How to create arrays in python.
Inbuilt arrays concept is not there in python

## 2-ways:
1. By using array module
2. By using numpy module

## 1. By using array module(Not recommended)
import array
a = array.array('i',[10,20,30])#i represents type:int array
print(type(a))
print(a)
print('Elements one by one:')
for x in a:
	print(x)

Note:
	array module is not recommended because much library support is not available.

## 2.By using numpy module:
import numpy
a = numpy.array([10,20,30])
print(type(a))
print(a)
for x in a:
	print(x)

## Python's List vs Numpy ndarray:
## 1.Similarities:
-->Both are used to store data.
-->The order will be preserved in both. Hence indexing and slicing concepts are applicable.
-->Both are mutable, i.e we can change the content.

## 2.Differences:
1.list is pythons inbuilt type. We have to install and import numpy explicitly.
2.list can contain hetrogenious elements. But array contains only homogenious elements.

import numpy
l = [10,10.5,'Sunny',True]
print(l)#[10, 10.5, 'Sunny', True]
a = numpy.array(l)
print(a)#['10' '10.5' 'Sunny' 'True']

3.On list we cannot perform vector operations. But on ndarray we can perform vector operations

>>>l = [10,20,30,40]
>>>import numpy as np
>>>a = np.array(l)
>>>a #array([10, 20, 30, 40])
>>>l + 2 #Invalid
>>>a + 2 #array([12, 22, 32, 42])
>>>a / 2 #array([ 5., 10., 15., 20.])
>>>l * 2 #[10, 20, 30, 40, 10, 20, 30, 40]
>>>a * 2 #array([20, 40, 60, 80])

4.Arrays consumes less memory than list.
5.Array are superfast when compared with list.
6.Numpy arrays are more convinient to use while performing complex mathematical operations.

## How to create Numpy Arrays:
1.array()
2.arange()
3.linspace()
4.zeros()
5.ones()
6.full()
7.eye()
8.identity()
9.empty()
10.numpy.random
		1.randint()
		2.arnd()
		3.uniform()
		4.randn()
		5.normal()
		6.shuffle()

## 1.Creation of numpy arrays by using array():
For the given list or tuple

>>>import numpy as np
>>>help(np.array)

## 1-D array:
>>> l = [10,20,30]
>>> type(l)#<class 'list'>
>>> a = np.array(l)
>>> type(a)#<class 'numpy.ndarray'>
>>> a #array([10, 20, 30])
>>> a.ndim #1
>>> a.dtype #dtype('int32')

Note:
	a.ndim--->To know dimension of ndarray
	a.dtype--->To know data type of elements

## 2-D array creation:
[[10,20,30],[40,50,60],[70,80,90]]----->Nested List

>>> a = np.array([[10,20,30],[40,50,60],[70,80,90]])
>>> type(a) #<class 'numpy.ndarray'>
>>> a
>>> a.shape #(3, 3)
>>> a.ndim #2
>>> a.size #9

## To create 1-D array from the tuple
>>> a = np.array(('sunny','bunny','vinny'))
>>> a.ndim #1
>>> a.shape #(3,)
>>> a.dtype #dtype('<U5')

Note:Array contains only homogenious elements.
If the list contains hetrogenious elements:Upcasting will be performed.

>>> a = np.array([10,20,10.5])
>>> a #array([10. , 20. , 10.5]) Upcasting int to float
>>> a.dtype #dtype('float64')

>>> a = np.array([10,20,'a'])
>>> a #array(['10', '20', 'a'], dtype='<U11')

## How to create a particular type:
We have to use dtype parameter

>>> a = np.array([10,20,30.5],dtype=int)
>>> a #array([10, 20, 30])
>>> a = np.array([10,20,30.5],dtype=bool)
>>> a #array([ True,  True,  True])
>>> a = np.array([10,20,30.5],dtype=float)
>>> a #array([10. , 20. , 30.5])
>>> a = np.array([10,20,30.5],dtype=complex)
>>> a #array([10. +0.j, 20. +0.j, 30.5+0.j])

>>> a = np.array([10,'Sunny'],dtype=int) #Invalid

## How to create object type array:
Here any type of elements are allowed.

>>> a = np.array([10,'Sunny',True,10.5,10+3j],dtype=object)
>>> a #array([10, 'Sunny', True, 10.5, (10+3j)], dtype=object)

If we are not given dtype then
>>> a = np.array([10,'Sunny',True,10.5,10+3j])
>>> a #array(['10', 'Sunny', 'True', '10.5', '(10+3j)'], dtype='<U64')

array() ----> To create ndarray from the given list or tupe.

# Day-3

Day-1 https://youtu.be/z2Hq-8-fWrY
Day-2 https://youtu.be/uHsowtczZ3Y
# Day-3 https://youtu.be/rq0BWe2wYSY
## Creation of ndarray by using arange() function:
Python:
	range(10)==>0 to 9
	range(1,11)==>1 to 10
	range(1,11,2)==>1,3,5,7,9

>>> import numpy as np
>>> help(np.arange)
			
		 arange([start,] stop[, step,], dtype=None, *, like=None)

## Ex-1:create 1-D array 0 to 9
>>> a = np.arange(10)
>>> a #array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
>>> a.ndim #1
>>> a.shape #(10,)
>>> a.dtype #dtype('int32')
>>> a = np.arange(1,11)
>>> a #array([ 1,  2,  3,  4,  5,  6,  7,  8,  9, 10])
>>> a = np.arange(1,11,2)
>>> a #array([1, 3, 5, 7, 9])
>>> a = np.arange(1,11,3,dtype=float)
>>> a #array([ 1.,  4.,  7., 10.])

## 3).linspace()
	In the specified interval, linearly spaced values.

>>>help(np.linspace)
linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None, axis=0)
	 Return evenly spaced numbers over a specified interval.

Ex:
>>> np.linspace(0,1,2) #array([0., 1.])
>>> np.linspace(0,1,3) #array([0. , 0.5, 1. ])
>>> np.linspace(0,1,4) #array([0. , 0.33333333, 0.66666667, 1. ])
>>> np.linspace(0,1)
>>> np.linspace(0,1).size #50
>>> np.linspace(0,1).shape #(50,)
>>> np.linspace(1,100,10,dtype=int) #array([1,12,23,34,45,56,67,78,89,00])

1 to 12--->11 numbers
12 to 23--->11 numbers
equally spaced values

## arange() vs linspace():
arange()-->Elements will be considered in the given range based on step value.
linspace()-->The specified number of values will be considered in the given range.

## 4.zeros():
(10,)--->1-D array contains 10-elements

(5,2)--->2-D array contains 5-rows and 2-columns
			2-D array means collection of 1-D arrays

(2,3,4)--->3-D array
			3-D array contains a collection of 2-D arrays
			2--->2 number of 2-D arrays
			3--->The number of rows in every 2-D array
			4-->The number of columns in every 2-D array
			size:24
			
>>>help(np.zeros)
		 zeros(shape, dtype=float, order='C', *, like=None)

>>> np.zeros(4) #array([0., 0., 0., 0.])
>>> np.zeros((4,)) #array([0., 0., 0., 0.])
>>> np.zeros((4,3))
>>> np.zeros((2,3,4))
>>> np.zeros((1,3,2))

-->Perform some operations the result we have to store somewhere.

## 5.ones():
Exactly same as zeros except that instead of zero array filled with 1.
fill_value:1

>>> help(np.ones)
		ones(shape, dtype=None, order='C', *, like=None)
			Return a new array of given shape and type, filled with ones.
## Ex:
>>> np.ones(10)
>>> np.ones((4,2))
>>> np.ones((4,2),dtype=int)
>>> np.ones((2,3,4),dtype=int)

## 6.full():
>>> help(np.full)
		full(shape, fill_value, dtype=None, order='C', *, like=None)
			 Return a new array of given shape and type, filled with `fill_value`.

>>> np.full(10) #full() missing 1 required positional argument: 'fill_value'
>>> np.full(10,2)
>>> np.full(10,3)
>>> np.full((5,4),9)
>>> np.full((2,3,4),6)

Note:
	1).np.full(shape=(5,4),fill_value=3)
	2).np.full((5,4),fill_value=3)
	3).np.full((5,4),3)
	4).np.full(shape=(5,4),3)#positional argument follows keyword argument

## 7).eye():
>>>help(np.eye)
eye(N, M=None, k=0, dtype=<class 'float'>, order='C', *, like=None)
    Return a 2-D array with ones on the diagonal and zeros elsewhere.

N--->Number of rows
M--->Number of columns
K--->Meant for diagnol
0 1 2 3 4
-1
-2
-3
-4

Ex:
>>> np.eye(2,3)
>>> np.eye(3,dtype=int)
>>> np.eye(5,dtype=int)
>>> np.eye(5,k=1,dtype=int)
>>> np.eye(5,k=-3,dtype=int)

## 8).identity():
It is exactly same as eye() function except that
	1).It is always square matrix(the number of rows and number of columns always same)
	2).Only main diagnol contains 1's
identity() is a special case of eye()

>>>help(np.identity)
identity(n, dtype=None, *, like=None)
    Return the identity array.

Ex:
>>> np.identity(5)
>>> np.identity(5,dtype=int)

## 9.empty():
>>>help(np.empty)
		empty(shape, dtype=float, order='C', *, like=None)
    Return a new array of given shape and type, without initializing entries.

Ex:
>>> np.empty(3)
>>> np.empty((3,3))
>>> np.empty(10)

## zeros() vs empty():
-->If we required an array only with zeros then we should go for zeros()
-->If we never worry about data, just we required an empty array for future purpose, then we should go for empty().
-->Th etime required to create empty array is very very less when compared with zeros array. i.e performance wise empty function is recommended than zeros if we are not worry about data.

#Performace comparisiob of zeros() and empty()
import numpy as np
from datetime import datetime
begin = datetime.now()
a = np.zeros((10000,300,400))
after = datetime.now()
print('Time taken by zeros:',after-begin)
a = None
begin = datetime.now()
a = np.empty((10000,300,400))
after = datetime.now()
print('Time taken by empty:',after-begin)

# Day-4:
Day-1 https://youtu.be/z2Hq-8-fWrY
Day-2 https://youtu.be/uHsowtczZ3Y
Day-3 https://youtu.be/rq0BWe2wYSY
## Day-4 https://youtu.be/TpozMOoNwoU

## Array creation by using random module:
randint()
rand()
uniform()
randn()
normal()
shuffle()

1.randint():
	To generate random int values in the given range.

>>> import numpy as np
>>> help(np.randint) #Error
>>> help(np.random.randint)
		randint(low, high=None, size=None, dtype=int)
	    Return random integers from 'low' (inclusive) to 'high' (exclusive).
		[low,high)

## Ex:
>>> np.random.randint(10,20)

## 1-D array
>>> np.random.randint(1,10,size=10)

## 2-D array
>>> np.random.randint(100,size=(3,5)) 

## 3-D array
>>> np.random.randint(100,size=(2,3,4))

Ex:
>>>  np.random.randint(1,10,size=10,dtype=float)
TypeError: Unsupported dtype dtype('float64') for randint

Syn:
	randint(low, high=None, size=None, dtype=int)

int8,int16,int32,int64

>>> a = np.random.randint(1,10,size=(20,30))
>>> a.dtype #int32
>>> a = np.random.randint(1,10,size=(20,30),dtype='int8')
>>> a.dtype #int8==> Memory utilization

Ex:
>>> import sys
>>> a = np.random.randint(1,10,size=(20,30))
>>> sys.getsizeof(a) #2528
>>> a = np.random.randint(1,10,size=(20,30),dtype='int8')
>>> sys.getsizeof(a) #728

## How to convert from one array type to another type
We have to use astype() method

>>> a = np.random.randint(1,10,size=(20,30))
>>> a.dtype #dtype('int32')
>>> b = a.astype('float')
>>> b.dtype #dtype('float64')

## 2).rand():
uniform distribution	---> 10 11 9 10 11 10
normal distribution	---> 6 4 10 4 14(10 is mean value)

It will generate random float values in the range [0,1) from uniform distribution samples.

Ex:
>>> np.random.rand() #A single float value will be generated

## 1-D array
>>> np.random.rand(10)

## 2-D array
>>> np.random.rand(3,5)

## 3-D array
>>> np.random.rand(2,3,4)

## 3).uniform():
rand() ---> range is always [0,1)
uniform() ---> customize range
	uniform(low=0.0, high=1.0, size=None)

Ex:
>>> np.random.uniform()
>>> np.random.uniform(10,20)

1-D array: >>> np.random.uniform(10,20,size=5)
2-D array: >>> np.random.uniform(10,20,size=(3,4))
3-D array: >>> np.random.uniform(10,20,size=(2,3,2))

4).randn():
	values from normal distribution with mean 0 and variance is 1

>>> np.random.randn(10)
>>> np.random.randn(2,3)
>>> np.random.randn(2,3,4)

5).normal():
	We can customize mean and variance

	normal(loc=0.0, scale=1.0, size=None)

>>> np.random.normal(10,4,size=10)
>>> np.random.normal(10,4,size=(2,3,4))

## 6).shuffle():
>>> help(np.random.shuffle)

## 1-D array:
>>> a = np.arange(9)
>>> a
>>> np.random.shuffle(a) #inline shuffling happens
>>> a

## 2-D array:
>>> a = np.random.randint(1,101,size=(6,5))
>>> a
>>> np.random.shuffle(a)
>>> a

## 3-D array:(4,3,4)
If we apply shuffle for 3-D array, then the order of 2-D arrays will be changed but not it's internal content

>>> a = np.arange(48).reshape(4,3,4)
>>> a
>>> np.random.shuffle(a)
>>> a

## Summary of random library functions:
1.randint()==>To generate random int values in the given range.
2.rand()==>To generate uniform distributed float values in [0,1)
3.uniform()==>To generate uniform distributed float values in the given range.[low,high)
4.randn()==>normal distributed float values with mean 0 and standart deviation 1.
5.normal()==>normal distributed float values with specified mean and standard deviation.
6.shuffle()==>To shuffle order of elements in the given nd array.

## Array attributes:
1.ndim ===>returns the dimension of the array
2.shape===>returns the shape of the array.(10,):1-D, (10,3):2-D
3.size===>To get total number of elements.
4.dtype===>To get data type of elements of the array.
5.itemsize===>Length of each element of array in bytes(4-bytes)

## Ex:
>>> a = np.array([10,20,30,40])
>>> a.ndim #1
>>> a.shape #(4,)
>>> a.size #4
>>> a.dtype #dtype('int32')
>>> a.itemsize #4

## Ex:
>>> a = np.array([[10,20,30],[40,50,60],[70,80,90]],dtype='float')
>>> a.ndim #2
>>> a.shape #(3, 3)
>>> a.size #9
>>> a.dtype #dtype('float64')
>>> a.itemsize #8

# Day-5
Day-1 https://youtu.be/z2Hq-8-fWrY
Day-2 https://youtu.be/uHsowtczZ3Y
Day-3 https://youtu.be/rq0BWe2wYSY
Day-4 https://youtu.be/TpozMOoNwoU
Day-5 https://youtu.be/N3mXkipScMU

## Numpy Data Types:
Python data types:int,float,str,complex,bool etc.......

Numpy data types:Multiple data types present(Python + C)

i===>integer(int8,int16,int32,int64)
b===>boolean
u===>unsigned integer(uint8,uint16,uint32,uint64)
f===>float(float16,float32,float64)
c===>complex(complex64,complex128)
s==>String
U==>Unicode String
M===>datetime etc.....

int8==>i1; int16==>i2; int32==>i4(default)
float16==>f2; float32==>f4(default); float64==>f8

int8:
	-->The value will be represented by 8bits.
	-->MSB is reserved for sign
	-->The range:-128 to 127

import sys
import numpy as np
a = np.array([10,20,30,40])
print(sys.getsizeof(a))
a = np.array([10,20,30,40],dtype='int8')
print(sys.getsizeof(a))

## Changing the data type of an existing array
1).astype()
2).By using built-in function of numpy like float64()

Ex:
import numpy as np
a = np.array([10,20,30,40])
b = a.astype('float64')
print(a.dtype)#int32
print(b.dtype)#float64

Ex:
a = np.array([10,20,30,40])
b = np.float64(a)
print(a.dtype)
print(b.dtype)

Ex:
a = np.array([10,0,30,0])
x = np.bool(a)#Invalid

x = np.bool_(a)
print(x)

## How to get/access elements of Numpy Array:
1.Indexing
2.Slicing
3.Advanced Indexing

1.Indexing:
	By using index, we can get single element of the array.
	zero based indexing. i.e the index of first element is 0
	supports both +ve and -ve indexing

## From 1-D array:
a[index]
>>> a = np.array([10,20,30,40])
>>> a #array([10, 20, 30, 40])
>>> a[0] #10
>>> a[-1] #40
>>> a[10] #IndexError

## From 2-D array:
a[rowindex][columnindex]

>>> a = np.array([[10,20,30],[40,50,60]])
>>> a
array([[10, 20, 30],
       [40, 50, 60]])

## To Access 50
>>> a[1][1]
>>> a[1][-2]
>>> a[-1][-2]
>>> a[-1][1]

## From 3-D array:
(2,3,4)
	a[i][j][k]:
		i-->represents which 2-D array(index of 2-D array)
		j-->represents row index in that 2-D array
		k-->represents column index in that 2-D array

a[0][1][2]:
	0-indexed 2-D array
	In that 2-D array 1 indexed row and 2 indexed column

>>> l = [[[1,2,3],[4,5,6],[7,8,9]],[[10,11,12],[13,14,15],[16,17,18]]]
>>> a = np.array(l)
>>> a

## To access 14:
>>> a[1][1][1]
>>> a[-1][-2][-2]
>>> a[1][-2][-2]
>>> a[-1][1][-2]

## Accessing elements of ndarray by using slice operator:
a[begin:end:step]

## 1-D array:
>>> a = np.arange(10,101,10)
>>> a
>>> a[2:5]
>>> a[::1]
>>> a[::-1]
>>> a[::-2]

## 2-D array:
a[row,column]
a[begin:end:step, begin:end:step]

>>> a = np.array([[10,20],[30,40],[50,60]])
>>> a
array([[10, 20],
       [30, 40],
       [50, 60]])

## Access [10, 20]
>>> a[0:1,:]

>>> a[0,:]
array([10, 20])#It is 1-D array

>>> a[0::2,:]
array([[10, 20],
       [50, 60]])

>>> a[0:2,1:2]
array([[20],
       [40]])

>>> a[:2,1:]
array([[20],
       [40]])

## Ex:
>>> a = np.array([[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]])
>>> a
array([[ 1,  2,  3,  4],
       [ 5,  6,  7,  8],
       [ 9, 10, 11, 12],
       [13, 14, 15, 16]])

>>> a[0:2,:]
array([[1, 2, 3, 4],
       [5, 6, 7, 8]])

>>> a[0::3,:]
array([[ 1,  2,  3,  4],
       [13, 14, 15, 16]])

>>> a[:,0:2]
array([[ 1,  2],
       [ 5,  6],
       [ 9, 10],
       [13, 14]])

>>> a[:,::2]
array([[ 1,  3],
       [ 5,  7],
       [ 9, 11],
       [13, 15]])

>>> a[1:3,1:3]
array([[ 6,  7],
       [10, 11]])

>>> a[::3,::3]
array([[ 1,  4],
       [13, 16]])
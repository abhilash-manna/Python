##### Day-1 [27-02-2025]
# Python for Data Science, ML, DL and AI:
Devops --> Regular core python knowledge concise code  
Rich libraries --->70 to 90% our libraries 10% we have to write the code.

## What is this line in python?
```python
import numpy as np
# Numpy-->Entry point from python for DS
# Numpy-->Numerical Python Library
```
## How to install Numpy?
```python
>>>pip install numpy
```

## How to check version:
```python
D:\Mahesh_Classes>py
>>> import numpy as np
>>> np.__version__
```
## What is the need of Numpy?
Python performs basic mathematical operations.

```python
a = 10
b = 20
a+b
a-b
a/b
a*b

math.sqrt(4)
```
But in Data Science, ML, DL and AI required complex matghematical operations....

* 1. Numpy defines several functions to perform **complex mathematical operations**.
* 2. To fullfill performance gaps most of the Numpy is **implemented in C-Language** superfast
* 3. nd array(To store large data in nd array for matplotlib graph style) -->n dimensional array or numpy array

```py
# Ex:
# matrix with all zero 10X10 shape
# l = [[0,0,0,0...],[],[],......[]]

	>>>import numpy as np
	>>>a = np.zeros((10,10))
	>>>a

# If you want only int type:
	>>> a = np.zeros((10,10),dtype=int)

# list of 100-numbers:
	>>>a = np.arange(1,101)
	>>>a

# pls convert into 2-dimension array
	>>>a.reshape(10,10)

# Identity matrix?
	>>>a = np.identity(3)
	>>>a = np.identity(5)
```
* 4. Data Analysis:  
     2 crore samples are analyzed  
     100 -->points  
     new patient--->corona  

## History of Numpy:
Origin of Numpy---->Numeric Library  
Numeric Library--->**Jim Hugunin**  
Numpy-->**Travis Oliphant(2005)**  
Open source library and freeware  

## Q.In which language Numpy was written?  
**C and Python**

## Q.What is nd array in numpy?
The fundamental data type to store our data : nd array
```python
>>> a = np.identity(5)
>>> type(a) #<class 'numpy.ndarray'>
>>> help(np.ndarray)
Help on class ndarray in module numpy:
arrays are objects of ndarray class present in numpy module
```
Array: An indexed collection of homogenious elements

1-D array	---> Vector  
2-D array	---> Matrix  
.  
.  
.  
n-D array	---> No name  

#### Day-1 https://youtu.be/z2Hq-8-fWrY

##### Day-2 [27-02-2025] 
# Numpy Basic Introduction

## Ex: What is the need of Numpy
```py
Boys and Girls are attending Mahesh sir datascience class.
For boys fee is $3 and for girls fees is $8, For a certain batch 2200 people attended and $10100 fee collected. How many boys and girls attended for that batch.

x --->no of boys
y --->no of girls

x + y = 2200
3x + 8y = 10100

coefficient matrix:
a =	1 1
	3 8
value matrix
b = [2200,10100]

numpy.linalg.solve(a,b)

>>> import numpy as np
>>> a = np.array([[1,1],[3,8]])
>>> a
array([[1, 1],
       [3, 8]])
>>> b = np.array([2200,10100])
>>> b
array([ 2200, 10100])
>>> np.linalg.solve(a,b)
array([1500.,  700.])
```
## Array:
An indexed collection of homogenious data elements.

## How to create arrays in python.
Inbuilt arrays concept is not there in python

### 2-ways:
* 1. By using array module
* 2. By using numpy module

### 1. By using array module (Not recommended)
```py
import array
a = array.array('i',[10,20,30])#i represents type:int array
print(type(a))
print(a)
print('Elements one by one:')
for x in a:
	print(x)

Note:
	array module is not recommended because much library support is not available.
```

###  2. By using numpy module:
```py
import numpy
a = numpy.array([10,20,30])
print(type(a))
print(a)
for x in a:
	print(x)
```
## Python's List vs Numpy ndarray:
### 1. Similarities:
* Both are used to store data.  
* The order will be preserved in both. Hence indexing and slicing concepts are applicable.  
* Both are mutable, i.e we can change the content.  

### 2. Differences:
* list is pythons inbuilt type. We have to install and import numpy explicitly.
* list can contain hetrogenious elements. But array contains only homogenious elements.
```py
import numpy
l = [10,10.5,'Sunny',True]
print(l)#[10, 10.5, 'Sunny', True]
a = numpy.array(l)
print(a)#['10' '10.5' 'Sunny' 'True']
```
* On list we cannot perform vector operations. But on ndarray we can perform vector operations
```py
>>>l = [10,20,30,40]
>>>import numpy as np
>>>a = np.array(l)
>>>a #array([10, 20, 30, 40])
>>>l + 2 #Invalid
>>>a + 2 #array([12, 22, 32, 42])
>>>a / 2 #array([ 5., 10., 15., 20.])
>>>l * 2 #[10, 20, 30, 40, 10, 20, 30, 40]
>>>a * 2 #array([20, 40, 60, 80])
```
* Arrays consumes less memory than list.
* Array are superfast when compared with list.
* Numpy arrays are more convinient to use while performing complex mathematical operations.

## How to create Numpy Arrays:
* 1. array()
* 2. arange()
* 3. linspace()
* 4. zeros()
* 5. ones()
* 6. full()
* 7. eye()
* 8. identity()
* 9. empty()
* 10. numpy.random
 	* 1. randint()
 	* 2. arnd()
 	* 3. uniform()
 	* 4. randn()
  	* 5. normal()
  	* 6. shuffle()  

### 1. Creation of numpy arrays by using array():
```py
## For the given list or tuple
>>>import numpy as np
>>>help(np.array)

## 1-D array:
>>> l = [10,20,30]
>>> type(l)#<class 'list'>
>>> a = np.array(l)
>>> type(a)#<class 'numpy.ndarray'>
>>> a #array([10, 20, 30])
>>> a.ndim #1
>>> a.dtype #dtype('int32')

## Note:
	a.ndim--->To know dimension of ndarray
	a.dtype--->To know data type of elements

## 2-D array creation:
[[10,20,30],[40,50,60],[70,80,90]]----->Nested List

>>> a = np.array([[10,20,30],[40,50,60],[70,80,90]])
>>> type(a) #<class 'numpy.ndarray'>
>>> a
>>> a.shape #(3, 3)
>>> a.ndim #2
>>> a.size #9

## To create 1-D array from the tuple
>>> a = np.array(('sunny','bunny','vinny'))
>>> a.ndim #1
>>> a.shape #(3,)
>>> a.dtype #dtype('<U5')

Note:Array contains only homogenious elements.
If the list contains hetrogenious elements:Upcasting will be performed.

>>> a = np.array([10,20,10.5])
>>> a #array([10. , 20. , 10.5]) Upcasting int to float
>>> a.dtype #dtype('float64')

>>> a = np.array([10,20,'a'])
>>> a #array(['10', '20', 'a'], dtype='<U11')

## How to create a particular type:
We have to use dtype parameter

>>> a = np.array([10,20,30.5],dtype=int)
>>> a #array([10, 20, 30])
>>> a = np.array([10,20,30.5],dtype=bool)
>>> a #array([ True,  True,  True])
>>> a = np.array([10,20,30.5],dtype=float)
>>> a #array([10. , 20. , 30.5])
>>> a = np.array([10,20,30.5],dtype=complex)
>>> a #array([10. +0.j, 20. +0.j, 30.5+0.j])

>>> a = np.array([10,'Sunny'],dtype=int) #Invalid

## How to create object type array:
Here any type of elements are allowed.

>>> a = np.array([10,'Sunny',True,10.5,10+3j],dtype=object)
>>> a #array([10, 'Sunny', True, 10.5, (10+3j)], dtype=object)

If we are not given dtype then
>>> a = np.array([10,'Sunny',True,10.5,10+3j])
>>> a #array(['10', 'Sunny', 'True', '10.5', '(10+3j)'], dtype='<U64')

array() ----> To create ndarray from the given list or tuple.
```
#### Day-2 https://youtu.be/uHsowtczZ3Y

# Day-3

### 2. Creation of ndarray by using arange() function:
```py
Python:
	range(10)==>0 to 9
	range(1,11)==>1 to 10
	range(1,11,2)==>1,3,5,7,9

>>> import numpy as np
>>> help(np.arange)
			
		 arange([start,] stop[, step,], dtype=None, *, like=None)

## Ex-1:create 1-D array 0 to 9
>>> a = np.arange(10)
>>> a #array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
>>> a.ndim #1
>>> a.shape #(10,)
>>> a.dtype #dtype('int32')
>>> a = np.arange(1,11)
>>> a #array([ 1,  2,  3,  4,  5,  6,  7,  8,  9, 10])
>>> a = np.arange(1,11,2)
>>> a #array([1, 3, 5, 7, 9])
>>> a = np.arange(1,11,3,dtype=float)
>>> a #array([ 1.,  4.,  7., 10.])
```
### 3. Creation of numpy arrays by using linspace() function:
```py
	In the specified interval, linearly spaced values.
>>>help(np.linspace)
linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None, axis=0)
	 Return evenly spaced numbers over a specified interval.

Ex:
>>> np.linspace(0,1,2) #array([0., 1.])
>>> np.linspace(0,1,3) #array([0. , 0.5, 1. ])
>>> np.linspace(0,1,4) #array([0. , 0.33333333, 0.66666667, 1. ])
>>> np.linspace(0,1)
>>> np.linspace(0,1).size #50
>>> np.linspace(0,1).shape #(50,)
>>> np.linspace(1,100,10,dtype=int) #array([1,12,23,34,45,56,67,78,89,00])

1 to 12--->11 numbers
12 to 23--->11 numbers
equally spaced values
```
### arange() vs linspace():
* arange() --> Elements will be considered in the given range based on step value.
* linspace() --> The specified number of values will be considered in the given range.

### 4. Creation of numpy arrays by using zeros() function:
```py
(10,)--->1-D array contains 10-elements

(5,2)--->2-D array contains 5-rows and 2-columns
			2-D array means collection of 1-D arrays

(2,3,4)--->3-D array
			3-D array contains a collection of 2-D arrays
			2--->2 number of 2-D arrays
			3--->The number of rows in every 2-D array
			4-->The number of columns in every 2-D array
			size:24
			
>>>help(np.zeros)
		 zeros(shape, dtype=float, order='C', *, like=None)

>>> np.zeros(4) #array([0., 0., 0., 0.])
>>> np.zeros((4,)) #array([0., 0., 0., 0.])
>>> np.zeros((4,3))
>>> np.zeros((2,3,4))
>>> np.zeros((1,3,2))

-->Perform some operations the result we have to store somewhere.
```

### 5. Creation of numpy arrays by using ones() function:
```py
Exactly same as zeros except that instead of zero array filled with 1.
fill_value:1

>>> help(np.ones)
		ones(shape, dtype=None, order='C', *, like=None)
			Return a new array of given shape and type, filled with ones.
## Ex:
>>> np.ones(10)
>>> np.ones((4,2))
>>> np.ones((4,2),dtype=int)
>>> np.ones((2,3,4),dtype=int)
```
### 6. Creation of numpy arrays by using full() function:
```py
>>> help(np.full)
		full(shape, fill_value, dtype=None, order='C', *, like=None)
			 Return a new array of given shape and type, filled with `fill_value`.

>>> np.full(10) #full() missing 1 required positional argument: 'fill_value'
>>> np.full(10,2)
>>> np.full(10,3)
>>> np.full((5,4),9)
>>> np.full((2,3,4),6)

Note:
	1). np.full(shape=(5,4),fill_value=3)
	2). np.full((5,4),fill_value=3)
	3). np.full((5,4),3)
	4). np.full(shape=(5,4),3)#positional argument follows keyword argument
```
### 7. Creation of numpy arrays by using eye() function:
```py
>>>help(np.eye)
eye(N, M=None, k=0, dtype=<class 'float'>, order='C', *, like=None)
    Return a 2-D array with ones on the diagonal and zeros elsewhere.

N--->Number of rows
M--->Number of columns
K--->Meant for diagonal
0 1 2 3 4
-1
-2
-3
-4

Ex:
>>> np.eye(2,3)
>>> np.eye(3,dtype=int)
>>> np.eye(5,dtype=int)
>>> np.eye(5,k=1,dtype=int)
>>> np.eye(5,k=-3,dtype=int)
```
### 8. Creation of numpy arrays by using identity() function:
```py
It is exactly same as eye() function except that
	1). It is always square matrix(the number of rows and number of columns always same)
	2). Only main diagnol contains 1's

identity() is a special case of eye()

>>>help(np.identity)
identity(n, dtype=None, *, like=None)
    Return the identity array.

Ex:
>>> np.identity(5)
>>> np.identity(5,dtype=int)
```
### 9. Creation of numpy arrays by using empty() function:
```py
>>>help(np.empty)
		empty(shape, dtype=float, order='C', *, like=None)
    Return a new array of given shape and type, without initializing entries.

Ex:
>>> np.empty(3)
>>> np.empty((3,3))
>>> np.empty(10)
```
### zeros() vs empty():
* If we required an array only with zeros then we should go for zeros()
* If we never worry about data, just we required an empty array for future purpose, then we should go for empty().
* The time required to create empty array is very very less when compared with zeros array.
  i.e **performance wise empty function is recommended than zeros if we are not worry about data.**
```py
#Performace comparisiob of zeros() and empty()
import numpy as np
from datetime import datetime
begin = datetime.now()
a = np.zeros((10000,300,400))
after = datetime.now()
print('Time taken by zeros:',after-begin)
a = None
begin = datetime.now()
a = np.empty((10000,300,400))
after = datetime.now()
print('Time taken by empty:',after-begin)
```
#### Day-3 https://youtu.be/rq0BWe2wYSY

##### Day-4:

## 10. Array creation by using random module:
* randint()
* rand()
* uniform()
* randn()
* normal()
* shuffle()

### 1. randint():
```py
	To generate random int values in the given range.

>>> import numpy as np
>>> help(np.randint) #Error
>>> help(np.random.randint)
		randint(low, high=None, size=None, dtype=int)
	    Return random integers from 'low' (inclusive) to 'high' (exclusive).
		[low,high)

## Ex:
>>> np.random.randint(10,20)

## 1-D array
>>> np.random.randint(1,10,size=10)

## 2-D array
>>> np.random.randint(100,size=(3,5)) 

## 3-D array
>>> np.random.randint(100,size=(2,3,4))

Ex:
>>>  np.random.randint(1,10,size=10,dtype=float)
TypeError: Unsupported dtype dtype('float64') for randint

Syn:
	randint(low, high=None, size=None, dtype=int)

int8,int16,int32,int64

>>> a = np.random.randint(1,10,size=(20,30))
>>> a.dtype #int32
>>> a = np.random.randint(1,10,size=(20,30),dtype='int8')
>>> a.dtype #int8==> Memory utilization

Ex:
>>> import sys
>>> a = np.random.randint(1,10,size=(20,30))
>>> sys.getsizeof(a) #2528
>>> a = np.random.randint(1,10,size=(20,30),dtype='int8')
>>> sys.getsizeof(a) #728
```
### How to convert from one array type to another type

```py
We have to use astype() method

>>> a = np.random.randint(1,10,size=(20,30))
>>> a.dtype #dtype('int32')
>>> b = a.astype('float')
>>> b.dtype #dtype('float64')

### 2. rand():
```py
uniform distribution	---> 10 11 9 10 11 10
normal distribution	---> 6 4 10 4 14(10 is mean value)

It will generate random float values in the range [0,1) from uniform distribution samples.

Ex:
>>> np.random.rand() #A single float value will be generated

## 1-D array
>>> np.random.rand(10)

## 2-D array
>>> np.random.rand(3,5)

## 3-D array
>>> np.random.rand(2,3,4)
```
### 3. uniform():
```py
rand() ---> range is always [0,1)
uniform() ---> customize range
	uniform(low=0.0, high=1.0, size=None)

Ex:
>>> np.random.uniform()
>>> np.random.uniform(10,20)

1-D array: >>> np.random.uniform(10,20,size=5)
2-D array: >>> np.random.uniform(10,20,size=(3,4))
3-D array: >>> np.random.uniform(10,20,size=(2,3,2))
```
### 4. randn():
```py
	values from normal distribution with mean 0 and variance is 1

>>> np.random.randn(10)
>>> np.random.randn(2,3)
>>> np.random.randn(2,3,4)
```
### 5. normal():
```py
	We can customize mean and variance

	normal(loc=0.0, scale=1.0, size=None)

>>> np.random.normal(10,4,size=10)
>>> np.random.normal(10,4,size=(2,3,4))
```
### 6. shuffle():
```py
>>> help(np.random.shuffle)

## 1-D array:
>>> a = np.arange(9)
>>> a
>>> np.random.shuffle(a) #inline shuffling happens
>>> a

## 2-D array:
>>> a = np.random.randint(1,101,size=(6,5))
>>> a
>>> np.random.shuffle(a)
>>> a

## 3-D array:(4,3,4)
If we apply shuffle for 3-D array, then the order of 2-D arrays will be changed but not it's internal content

>>> a = np.arange(48).reshape(4,3,4)
>>> a
>>> np.random.shuffle(a)
>>> a
```
## Summary of random library functions:
* 1. randint() ==> To generate random int values in the given range.
* 2. rand() ==> To generate uniform distributed float values in [0,1)
* 3. uniform() ==> To generate uniform distributed float values in the given range.[low,high
* 4. randn() ==> normal distributed float values with mean 0 and standart deviation 1.
* 5. normal() ==> normal distributed float values with specified mean and standard deviation.
* 6. shuffle() ==> To shuffle order of elements in the given nd array.

## Array attributes:
* 1. ndim ===>returns the dimension of the array
* 2. shape===>returns the shape of the array.(10,):1-D, (10,3):2-D
* 3. size===>To get total number of elements.
* 4. dtype===>To get data type of elements of the array.
* 5. itemsize===>Length of each element of array in bytes(4-bytes)
```py
## Ex:
>>> a = np.array([10,20,30,40])
>>> a.ndim #1
>>> a.shape #(4,)
>>> a.size #4
>>> a.dtype #dtype('int32')
>>> a.itemsize #4

## Ex:
>>> a = np.array([[10,20,30],[40,50,60],[70,80,90]],dtype='float')
>>> a.ndim #2
>>> a.shape #(3, 3)
>>> a.size #9
>>> a.dtype #dtype('float64')
>>> a.itemsize #8
```
#### Day-4 https://youtu.be/TpozMOoNwoU

##### Day-5: 
# Numpy Data Types:

**Python data types:** int,float,str,complex,bool etc.......

**Numpy data types:** Multiple data types present(Python + C)

* i===>integer(int8,int16,int32,int64)
  ```py
  int8==>i1;
  int16==>i2;
  int32==>i4 (default)
  ```
* b===>boolean
* u===>unsigned integer(uint8,uint16,uint32,uint64)
* f===>float(float16,float32,float64)
  ```py
  float16==>f2;
  float32==>f4(default);
  float64==>f8
  ```
* c===>complex(complex64,complex128)
* s==>String
* U==>Unicode String
* M===>datetime etc.....

### int8:
-->The value will be represented by 8bits.  
-->MSB is reserved for sign  
-->The range:-128 to 127  
```py
import sys
import numpy as np
a = np.array([10,20,30,40])
print(sys.getsizeof(a))
a = np.array([10,20,30,40],dtype='int8')
print(sys.getsizeof(a))
```
## Changing the data type of an existing array
* 1) astype()
* 2) By using built-in function of numpy like float64()
```py
Ex:
import numpy as np
a = np.array([10,20,30,40])
b = a.astype('float64')
print(a.dtype)#int32
print(b.dtype)#float64

Ex:
a = np.array([10,20,30,40])
b = np.float64(a)
print(a.dtype)
print(b.dtype)

Ex:
a = np.array([10,0,30,0])
x = np.bool(a)#Invalid

x = np.bool_(a)
print(x)
```
## How to get/access elements of Numpy Array:
* 1. Indexing
* 2. Slicing
* 3. Advanced Indexing

### 1.Indexing:
By using index, we can get single element of the array.  
zero based indexing. i.e the index of first element is 0  
supports both +ve and -ve indexing  

```py
## From 1-D array:
a[index]
>>> a = np.array([10,20,30,40])
>>> a #array([10, 20, 30, 40])
>>> a[0] #10
>>> a[-1] #40
>>> a[10] #IndexError

## From 2-D array:
a[rowindex][columnindex]

>>> a = np.array([[10,20,30],[40,50,60]])
>>> a
array([[10, 20, 30],
       [40, 50, 60]])

## To Access 50
>>> a[1][1]
>>> a[1][-2]
>>> a[-1][-2]
>>> a[-1][1]

## From 3-D array:
(2,3,4)
	a[i][j][k]:
		i-->represents which 2-D array(index of 2-D array)
		j-->represents row index in that 2-D array
		k-->represents column index in that 2-D array

a[0][1][2]:
	0-indexed 2-D array
	In that 2-D array 1 indexed row and 2 indexed column

>>> l = [[[1,2,3],[4,5,6],[7,8,9]],[[10,11,12],[13,14,15],[16,17,18]]]
>>> a = np.array(l)
>>> a

## To access 14:
>>> a[1][1][1]
>>> a[-1][-2][-2]
>>> a[1][-2][-2]
>>> a[-1][1][-2]
```
### 2. Slicing : Accessing elements of ndarray by using slice operator:
a[begin:end:step]
```py
## 1-D array:
>>> a = np.arange(10,101,10)
>>> a
>>> a[2:5]
>>> a[::1]
>>> a[::-1]
>>> a[::-2]

## 2-D array:
a[row,column]
a[begin:end:step, begin:end:step]

>>> a = np.array([[10,20],[30,40],[50,60]])
>>> a
array([[10, 20],
       [30, 40],
       [50, 60]])

## Access [10, 20]
>>> a[0:1,:]

>>> a[0,:]
array([10, 20])#It is 1-D array

>>> a[0::2,:]
array([[10, 20],
       [50, 60]])

>>> a[0:2,1:2]
array([[20],
       [40]])

>>> a[:2,1:]
array([[20],
       [40]])

## Ex:
>>> a = np.array([[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]])
>>> a
array([[ 1,  2,  3,  4],
       [ 5,  6,  7,  8],
       [ 9, 10, 11, 12],
       [13, 14, 15, 16]])

>>> a[0:2,:]
array([[1, 2, 3, 4],
       [5, 6, 7, 8]])

>>> a[0::3,:]
array([[ 1,  2,  3,  4],
       [13, 14, 15, 16]])

>>> a[:,0:2]
array([[ 1,  2],
       [ 5,  6],
       [ 9, 10],
       [13, 14]])

>>> a[:,::2]
array([[ 1,  3],
       [ 5,  7],
       [ 9, 11],
       [13, 15]])

>>> a[1:3,1:3]
array([[ 6,  7],
       [10, 11]])

>>> a[::3,::3]
array([[ 1,  4],
       [13, 16]])
```
#### Day-5 https://youtu.be/N3mXkipScMU

##### Day-6 [28-02-2025]
Slice in 3-D array:
---
(2,3,4)  
(i,j,k)  

2 --> number of 2-D arrays  
3 --> the number of rows  
4 --> the number of columns  

	a[i,j,k]  
	a[begin:end:step,begin:end:step,begin:end:step]

```py
l = [[[1,2,3,4],
	[5,6,7,8],
	[9,10,11,12]],
	[[13,14,15,16],
	[17,18,19,20],
	[21,22,23,24]]]
>>> a = np.array(l)
>>> a
>>> a[:,:,0:1]
>>> a[:,0:1,:]
>>> a[:,::2,:]
>>> a[:,:2,1:3]
>>> a[:,::2,::3]
```
>[!Note]
>To use slice operator, compulsory elements should be in order. We cannot select elements which are out of order. i.e we cannot select arbitrary lements.  

## Advanced Indexing:

By using index, **we can access only one elment at a time**.  

	a[i], a[i][j], a[i][j][k]

By using slice operator **we can access multiple elements at a time**, but all elements should be in order.  

	a[begin:end:step]  
	a[begin:end:step,begin:end:step]  
	a[begin:end:step,begin:end:step,begin:end:step]  

## Accessing multiple arbitrary elements:

Access elements of 1-D array:
---

	1-D array:  
		array[x]:  
		x can be either nd array or list, which represents required indexes.


```py
>>> a = np.arange(10,101,10)
>>> a #array([ 10,  20,  30,  40,  50,  60,  70,  80,  90, 100])

Required values are:[30,50,60,90]
---------------------------------------------------
1st way:
------------
create ndarray with required indices
>>>>>> indices = np.array([2,4,5,8])

pass this indices array as argument to original array
>>> a[indices] #array([30, 50, 60, 90])

2nd way:
-------------
>>> l = [2,4,5,8]
>>> a[l] #array([30, 50, 60, 90])

values:[10,50,70,100]
---------------------------------
>>> a[[0,4,6,9]]

values:[10,100,50,70]
--------------------------------
>>> a[[0,9,4,6]]

values:[10,100]
-----------------------
>>> a[[0,-1]]
```
Access elements of 2-D array:
--------------------------------------------
```py
>>> l = [[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]]
>>> a = np.array(l)
>>> a

# I want to select:1,6,11,16
# Syntax:
#	a[[row_indices],[column_indices]]
#	a[[0,1,2,3],[0,1,2,3]]
#	It select elements from:(0,0),(1,1),(2,2) and (3,3)

>>> a[[0,1,2,3],[0,1,2,3]]
array([ 1,  6, 11, 16])

# Ex:To select:2,8,9,15
# ---------------------------------
>>> a[[0,1,2,3],[1,3,0,2]]

# L-Shape elements:
# ---------------------------
>>> a[[0,1,2,3,3,3,3],[0,0,0,0,1,2,3]]
array([ 1,  5,  9, 13, 14, 15, 16])
```

Accessing multiple arbitrary elements in 3-D array:
-----------------------------------------------------------------------------
```py
>>> a = np.arange(1,25).reshape(2,3,4)
>>> a

# Accessing 7 and 18 from the array

# Syntax:
#		a[[indices of 2d array],[row indices],[column indices]]
	
# Step-1:	7:						18:
#			i = 0					i = 1
#			j = 1					j = 1
#			k = 2					k = 1
#
#			i:[0,1]
#			j:[1,1]
#			k:[2,1]

>>>a[[0,1],[1,1],[2,1]]
array([ 7, 18])
```
Condition based selection:
---------------------------------------
We can select elements based on some condition also.
Syn:
>		array[boolean_array]
> In the boolean array, where ever True present the corresponding value will be selected.

```py
>>> a = np.array([10,20,30,40])
>>> boolean_array = np.array([True,False,False,True])
>>> a[boolean_array] #array([10, 40])

# select elements which are greater than 25
# ---------------------------------------------------------------
>>> b_a = a>25
>>> a[b_a]#array([30, 40])

>>> a[a>25]#array([30, 40])

Ex:
>>> a = np.array([10,-5,20,40,-3,-1,75])
>>> a #array([10, -5, 20, 40, -3, -1, 75])
>>> a[a < 0] #array([-5, -3, -1])
>>> a[a > 0] #array([10, 20, 40, 75])
>>> a[a%2 == 0] #array([10, 20, 40])
>>> a[a%5 == 0] #array([10, -5, 20, 40, 75])

# Condition based selection 2-D array also
# ------------------------------------------------------------
```py
>>> a = np.arange(1,26).reshape(5,5)
>>> a
>>> a[a%2 == 0]
>>> a[a%10 == 0]
```
## Slicing vs Advanced Indexing:

Python's Slicing:
---

In case of list, **slice operator will creates a separate copy**
If we perform **any changes in one copy those changes wont be reflected in other copy**.
```py
l1 = [10,20,30,40]
l2 = l1[:]
l2[1] = 333
l1[1] = 999
print(l1)
print(l2)
```
Numpy Array Slicing:
--------------------------------
**A separate copy wont be created and just we are getting view of the original copy**
```py
>>> a = np.arange(10,101,10)
>>> a
>>> b = a[0:4]
>>> b
>>> a[0] = 333
>>> a
>>> b
>>> b[1] = 999
>>> b
>>> a
```
##### Day-7 [1-03-2025]

Advanced Indexing and Condition Based selection:
---
	-->It will select required elements based on provided index or condition, and with those elements a new 1-D array object will be created.
	-->The output is always a new 1-D array only.

```py
>>> a = np.arange(10,101,10)
>>> a #array([ 10,  20,  30,  40,  50,  60,  70,  80,  90, 100])
>>> b = a[[0,2,5]]
>>> b #array([10, 30, 60])
>>> a[0] = 333
>>> a #array([333,  20,  30,  40,  50,  60,  70,  80,  90, 100])
>>> b #array([10, 30, 60])
>>> b[0]=999
>>> b #array([999,  30,  60])
>>> a #array([333,  20,  30,  40,  50,  60,  70,  80,  90, 100])
```
Slicing vs Advanced Indexing
--------------------------------------------
	Slicing:
		-->The elements should be ordered.
		-->We can't select arbitrary elements.
		-->Conditional based selection is not possible.
		-->Just we will get View but not copy.
		-->Memory, performance-wise it is the best.

	Advanced Indexing:
		-->The elements need not be ordered.
		-->We can select arbitrary elements
		-->Condition based selection is possible.
		-->Just we will get separate copy but not view.
		-->Memory, performance-wise not up to the mark

Summary of syntaxes:
---------------------------------
Basic Indexing:
-----------------------
	1-D array: a[i]
	2-D array: a[i][j] or a[i,j]
	3-D array: a[i][j][k] or a[i,j,k]

Slicing:
-----------
	1-D array: a[begin:end:step]
	2-D array: a[begin:end:step,begin:end:step]
	3-D array: a[begin:end:step,begin:end:step,begin:end:step]

Advanced Indexing:
-----------------------------
	1-D array: a[x]-->x contains ndarray or list
	2-D array: a[[row_indices],[column_indices]]
	3-D array: a[[indices of 2D array],[row_indices],[column_indices]]

Condition based selection:
----------------------------------------
	a[condition]==>a[a>0]
	This is same for all 1-D,2-D and 3-D arrays

## How to iterate elements of the ndarray:

Iteration means getting all elements one-by-one
--
	3-ways:
		1.By using python's loops
		2.By using nditer() function
		3.By using ndenumerate() function  


1 : By using python's loops
---

To iterate elements of 1-D array
-----------------------------------------------
```py
import numpy as np
a = np.arange(10,51,10)
for x in a:
	print(x)
```
To iterate elements of 2-D array
-----------------------------------------------
```py
import numpy as np
a = np.array([[10,20,30],[40,50,60],[70,80,90]])
for x in a:#x is 1-D array but not scalar value
	for y in x:#y is a scalar value present in 1-D array
		print(y)
```
To iterate elements of 3-D array
------------------------------------------------
```py
import numpy as np
a = np.array([[[10,20],[30,40]],[[50,60],[70,80]]])
for x in a:#x is 2-D array but not scalar value
	for y in x:#y is 1-D array but not scalar value
		for z in y:#z is a scalar value
			print(z)
```
> [!Note]
> To iterate elements of n-D array, we required n-loops.

2 : By using numpy's nditer()
---------------------------------------
> [!Note]
> Advantage: For any n-D array only one loop is enough.

	nditer is a class present in numpy module.
	nditer() ---> Creating an object of inditer class.

1-D array:
---------------
```py
import numpy as np
a = np.arange(10,51,10)
for x in np.nditer(a):
	print(x)
```
2-D array:
---------------
```py
a = np.array([[10,20,30],[40,50,60],[70,80,90]])
for x in np.nditer(a):
	print(x)
```
3-D array:
---------------
```
a = np.array([[[10,20],[30,40]],[[50,60],[70,80]]])
for x in np.nditer(a):
	print(x)
```
Iterate elements of slicied array:
------------------------------------------------
```py
import numpy as np
a = np.array([[10,20,30],[40,50,60],[70,80,90]])
for x in np.nditer(a[:,:2]):
	print(x)
```
Using nditer() to get elements of required data type:
------------------------------------------------------------------------------
```py
# We have to use op_dtypes
>>>help(np.nditer)

a = np.array([[10,20,30],[40,50,60],[70,80,90]])
for x in np.nditer(a,flags=['buffered'],op_dtypes=['float']):
	print(x)
print(a)
```
Normal Python loops vs nditer():
------------------------------------------------

| Python loops | nditer |
|:--------------|:--------------|
| **n-loops** are required.|Only **one loop** is enough.| 
| Can not specify our required **dtype**. | Can specify required **dtype** by using **op_dtypes** argument.  |


##### Day-8 [3-03-2025]

3: By using ndenumerate() function
----------------------------------------------------
	If we want to find co-ordinates also in addition to element.
	array indices(coordinates) and values

1-D array
-------------------
```py
import numpy as np
a = np.array([10,20,30,40,50])
for pos,element in np.ndenumerate(a):
	print(f'{element} element present at index/position:{pos}')
```
2-D array:
---------------
```py
a = np.array([[10,20,30],[40,50,60],[70,80,90]])
for pos,element in np.ndenumerate(a):
	print(f'{element} element present at index/position:{pos}')
```
3-D array:
---------------
```py
a = np.arange(1,25).reshape(2,3,4)
for pos,element in np.ndenumerate(a):
	print(f'{element} element present at index/position:{pos}')
```
## Arithmetic operators:

		+, -, *, /, **, //

1-D array:
---------------
```py
>>> a = np.array([10,20,30,40])
>>> a #array([10, 20, 30, 40])
>>> a+2 #array([12, 22, 32, 42])
>>> a-2 #array([ 8, 18, 28, 38])
>>> a*2 #array([20, 40, 60, 80])
>>> a%2 #array([0, 0, 0, 0], dtype=int32)
>>> a/2 #array([ 5., 10., 15., 20.])
>>> a//2 #array([ 5, 10, 15, 20], dtype=int32)
```
2-D array:
--------------
```py
>>> a = np.array([[10,20,30],[40,50,60]])
>>> a
>>> a+2
>>> a-2
>>> a*2
>>> a**2
>>> a/2
>>> a//2
```

>[!Note]
>In python anything by zero including zero/zero results is : **ZeroDivisionError**
>
>But in Numpy there is **no ZeroDivisionError.**  
>10/0==>Infinity(inf)  
>0/0==>undefined(nan-->not a number)

Ex:
```py
>>> a = np.arange(6)
>>> a/0 #array([nan, inf, inf, inf, inf, inf])
```
Arithmetic operators for Arrays with Arrays:
------------------------------------------------------------------
	Compulsory both arrays should have:  
		--> Same dimension  
		--> Same shape and
		--> Same size
	-->otherwise we will get error.

1-D array:
---------------
```py
>>> a = np.array([1,2,3,4])
>>> b = np.array([10,20,30,40])
>>> a.ndim
>>> b.ndim
>>> a.shape
>>> b.shape
>>> a.size
>>> b.size
>>> a+b
>>> a-b
>>> a*b
>>> b/a
>>> b//a
```
2-D array
-------------
```py
>>> a = np.array([[1,2],[3,4]])
>>> b = np.array([[5,6],[7,8]])
>>> a+b
>>> a-b
>>> a*b
>>> b/a
>>> b//a
```
When shape is not same.  
Ex:
```py
>>> a = np.array([10,20,30])
>>> b = np.array([10,20,30,40])
>>> a+b
ValueError: operands could not be broadcast together with shapes (3,) (4,)
```
Equivalent numpy library function for arithmetic operators :
------------------------------------------------------------------------------------
universal function (ufunc) in the NumPy library that performs **element-wise addition of two arrays or a scalar and an array.**
```py
>>> a = np.array([10,20,30])
>>> b = np.array([1,2,3])
>>> np.add(a,b)
>>> np.subtract(a,b)
>>> np.multiply(a,b)
>>> np.divide(a,b)
>>> np.floor_divide(a,b)
>>> np.mod(a,b)
>>> np.power(a,b)
```
>[!Note]
>The functions which operates element by element on whole array are called as Universal functions(ufunc).

Broadcasting:
--------------------

>Eventhough **dimensions are different**, **shapes are different** and **sizes are different** **still some arithmetic operations are allowed by Broadcasting**.

>[!Note]
>Broadcasting will be **performed automatically by numpy itself** and we are not required to perform explicitly.

Rules for Broadcasting:
-----------------------------------
Rule-1:
-------
	Make sure both arrays should have same dimension  
	Padded(Add) 1's in the shape of lesser dimension array on the left side, until both arrays have same dimension.

	Before:
		(4,3)--->2-D
		(3,)---->1-D

	After:
		(4,3)--->2-D
		(1,3)--->2-D

Rule-2:
----------
	If the size of 2-arrays does not match in any dimension,
	then the arrays with size equal to 1 in that dimension will be increased to the size of other dimension to match.

	Note:
		If any dimension, the sizes are not matched and neither equal to 1,
		then we will get an error, Numpy does not able to perform broadcasting between those arrays.

	Before:
		(4,3)-->2-D
		(1,3)-->2-D

	Afetr:
		(4,3)-->2-D
		(4,3)-->2-D

	-->Now dimensions, shapes and size are equal.

Ex-2:
--------
```py
Broadcasting between (3,2,2) and (3,) possible or not
Before Rule-1:
	(3,2,2)
	(3,)
After Rule-1:
	(3,2,2)
	(1,1,3)

After Rule-2:
	(3,2,2)
	(3,2,3)

same dimension, but different shapes, so numpy unable to perform broacasting.

Note:
	The data will be reused from the same input array
	If the rows are required then re-use existing row
	If the columns are required then re-use existing columns
	The result is always higher dimension of input arrays
	input:3-D,1-D
	output:3-D

>>> a = np.array([10,20,30])	--->1-D	shape(3,)
>>> b = np.array([40])				--->1-D	shape(1,)
>>> a+b
array([50, 60, 70])	
```
Ex:
```py
>>> a = np.array([[10,20],[30,40],[50,60]])		--->2-D	shape(3,2)
>>> b = np.array([10,20])					-->1-D	shape(2,)
>>> a+b
array([[20, 40],
       [40, 60],
       [60, 80]])
```
Ex:
```py
>>> a = np.array([[10],[20],[30]])		-->2-D	shape(3,1)
>>> b = np.array([10,20,30])		-->1-D	shape(3,)
>>> a+b
array([[20, 30, 40],
       [30, 40, 50],
       [40, 50, 60]])
```

## Array Manipulation functions:
* 1.reshape()
* 2.resize()
* 3.flatten()
* 4.flat variable
* 5.ravel()
* 6.transpose()
* 7.swapaxes()

##### Day-9 [4-03-2025]

1.reshape():
----
	shape to another shape
	(10,)--->(5,2),(2,5),(10,1),(1,10)
	(24,)--->(3,8)-->(2,3,4),(6,4),(2,2,2,3)

1).The **data remian same** shoud not be changed and **input size and output size** must be matched .

Ex:
```py
>>> import numpy as np
>>> a = np.arange(10)
>>> a
>>> a.ndim #1
>>> a.shape #(10,)
>>> b = np.reshape(a,(5,2))
>>> b
>>> b = np.reshape(a,(10,1))
>>> b
>>> b = np.reshape(a,(1,5,2))#3-D array 5-rows and 2-columns
>>> b
```
Ex:
```py
>>> a = np.arange(24)
>>> a
>>> b = np.reshape(a,(6,4))
>>> b
>>> b = np.reshape(a,(2,3,4))
>>> b
>>> b = np.reshape(a,(6,5))
ValueError: cannot reshape array of size 24 into shape (6,5)
```
2).No change in the data.  
**New array object won't be created.**  
Just we are getting view of existing object,**view but not copy.**  
If we perform any **changes in the original array, that change will be reflected to reshaped array**. Viceversa.
```py
>>> a = np.arange(12)
>>> a
>>> b = np.reshape(a,(4,3))
>>> b
>>> a[0] = 333
>>> a
>>> b
>>> b[1][1] = 999
>>> b
>>> a
```
3). we can specify **unknown dimension size as -1.**

Ex:
```py
# a = (12,)
# b = (6,-1)===>(6,2)

>>> a = np.arange(12)
>>> b = np.reshape(a,(6,2))
>>> b
>>> b = np.reshape(a,(6,-1))
>>> b
>>> b = np.reshape(a,(-1,3))
>>> b
>>> b = np.reshape(a,(-1,-1))#Error

>>> a = np.arange(24)
>>> b = np.reshape(a,(2,3,-1))
>>> b = np.reshape(a,(2,-1,4))
>>> b = np.reshape(a,(-1,3,4))
>>> b = np.reshape(a,(3,4,-1))
>>> b = np.reshape(a,(5,-1))#Error
```
4).
```py
help(np.reshape)  
		reshape(a, newshape, order='C')
```
C style -->**Row major order**  
Fortran style --->**Column major order**

```py
>>> a = np.arange(12).reshape(3,4)
>>> a
>>> b = np.reshape(a,(12,),'C')
>>> b #array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11])
>>> b = np.reshape(a,(12,),'F')
>>> b #array([ 0,  4,  8,  1,  5,  9,  2,  6, 10,  3,  7, 11])
```
Ex:
```py
>>> a = np.arange(24,)
>>> a
>>> np.reshape(a,(6,4),'C')
>>> np.reshape(a,(6,4),'F')
```
Conclusion:
-----------------
>[!Note]
>1.To reshape array without changing data.  
>2.The size must be matched.  
>3.We can use either numpy library function or ndarray class method  
>				np.reshape()  
>				a.reshape()  
>4.It wont create a new array object, just we will get view.  
>5.We can use -1 in unknown dimension, but only once.  
>6.Order:'C','F'  

2).resize():
---------------
>[!Note]
>output array: can be any dimension, any shape, any size

	1).Input size and output size need not be matched.
	2).The data may be changed
	3).We will get copy but not view
	4).How to get that new data
			np.resize()--->repeat elements of input array
			a.resize()--->use zero for extra elements
	5). -1 such type of story not applicable for resize()
			input:(10,)
			reshape:(5,-1)
			resize:(5,-1)
	6).If we use ndarray class resize() method, inline modification will be happended.

Ex:
```py
>>> a = np.arange(1,6)
>>> a
>>> b = np.resize(a,(4,3))
>>> b
>>> a[0] = 333
>>> a
>>> b
>>> b[0][1]=999
>>> b
>>> a
>>> refcheck=False
>>> a = np.arange(1,6)
>>> a.resize(5,3)
>>> a
```

Q.Difference between np.resize() and ndarray.resize()?
------------------------------------------------------

| np.resize()     | ndarray.resize() |
|:----------------|:-----------------|
| 1). It is library function in numpy module. | 1). It is method present in ndarray class|
| 2). It will create new array and returned it.| 2). It wont return new array and existing array will be modified.|
|3). If the newshape required more elements then repeated copies of original array will be reused.|3). Extra elements filled with zeros. |

Q.Differences between reshape() and resize()?
-----------------------------------------------

| reshape()     | resize() |
|:----------------|:-----------------|
|1.It is just to reshape to array without changing size and data.|1.It is to resize() array, data may be changes, size may be changed.|
|2.Just view will be created but not copy,if we perform any change in the original array,automatically those changes will be reflected in reshaped copy also. |2.Separate copy will be created. If we perform any changes in the original array those changes wont be reflected in 	resize array.|
|3.We can use -1 in unknown dimension.|3.There is no story like -1.|



##### Day-10 [5-03-2025]

3: flatten():
-----------------

* convert any **n-D(1-D,2-D,3-D,n-D) array to 1-D array**.  
* It is **method present in ndarray class** but not numpy library function.  
	- **a.flatten() ==> valid**  
	- **np.flatten() ==> invalid**  
* a.flatten(**order='C'**)  
	- C-style ==> row major order  
	- F-style ==> column major order  
*  It will **create a new copy and returns it**(i.e copy but not view).  
*  The output of the flatten method is **always 1-D array**.  

Ex:
-----
```py
>>> a = np.arange(6).reshape(3,2)
>>> a
>>> a.flatten()
>>> a.flatten('F')
>>> b = a.flatten()
>>> a[0][0] = 3113
>>> a
>>> b
>>> b[1] = 999
>>> b
>>> a
```
Ex:
```py
>>> a = np.arange(1,19).reshape(3,3,2)
>>> a
>>> b=a.flatten()
>>> a.ndim #3
>>> b.ndim #1
>>> b
```
4: flat variable:
----------------------
It is a **1-D iterator over the array.**  
This is a **'numpy.flatiter' instance.**  

```py
>>> a = np.arange(1,19).reshape(3,3,2)
>>> a
>>> a.flat[2] #3
>>> a.flat[10] #11
>>> for x in a.flat:print(x)

>>> help(np.flatiter)
```
5: ravel()
--------------
* Convert any **n-D array to 1-D array**  
* It is **method present in ndarray class and also numpy library function**  
	* a.ravel() ==> valid  
	* np.ravel() ==> valid  
* a.ravel(**order='C'|'F'**)  
	- C-style ==> row major order  
	- F-style ==> column major order  
* It returns **view but not copy**.  
* The output of ravel method is **always 1-D array**.  

```py
>>> help(np.ravel)
>>> help(np.ndarray.ravel)
```
Ex:
```py
>>> a = np.arange(24).reshape(2,3,4)
>>> a
>>> b = a.ravel()
>>> b
>>> b[0] = 333
>>> b
>>> a
>>> a = np.arange(18).reshape(6,3)
>>> a
>>> b = np.ravel(a)
>>> b
```
Q.Difference between flatten() and ravel()?
--------------------------------------------------------------

|flatten()|ravel()|
|:-------|:---------|
|1. To convert any **n-D array to 1-D array and a new array object will be created**. |1. To convert any **n-D array to 1-D array but returns just view but not copy**.|
|2. If we perform any changes in the flatten copy, then those **changes wont be reflected in the original copy**.| 2. If we perform any **changes in the ravel copy, then those changes will be reflected in the original copy**.|
|3. It is **ndarray class method** but not numpy library function.|3. We can use as **method and as well as a function**.|


6: transpose() :
---------------------
```py
>>> help(np.transpose)

	transpose(a, axes=None)
    Reverse or permute the axes of an array; returns the modified array.
Ex:
>>> a = np.arange(1,5).reshape(2,2)
>>> a
>>> b = np.transpose(a)
>>> b

## Note:No change in data hence it returns only view but not copy

>>> a[0][0] = 333
>>> a
>>> b
```
for 3-D array :
---------------------
	(2,3,4)
	2---> 2-D arrays
	3---> 3 rows
	4---> 4 columns
	total size = 24

	transpose(a, axes=None)

	transpose(a) ==> (4,3,2)

```py
>>> a = np.arange(24).reshape(2,3,4)
>>> a
>>> b = np.transpose(a)
>>> b
>>> b.shape #(4, 3, 2)
```
Transpose of 1-D array:
-----------------------------------
Transpose of **1-D array will be generated same array only**

```py
>>> a = np.arange(6)
>>> a
>>> np.transpose(a)
```
Transpose 4-D array :
---------------
a = (2,3,4,5)  
np.transpose(a) ----> (5,4,3,2)

axes parameter:
-------------------------
* If we are **not using axes** parameter, then **dimension will be reversed**.  
* axes parameter tells in which order it has to take axes.  
* It is very helpful for 3-D and 4-D arrays.  

	for 3-D array : (2,3,4)

	The size of axis-0: 2
	The size of axis-1: 3
	The size of axis-2: 4

	np.transpose(a) ----> (4,3,2)

	My required order is:(2,4,3)/(4,2,3)/(3,4,2)
	np.transpose(a,axes=(0,2,1))/(2,0,1)/(1,2,0)

Ex:
----
```py
>>> a = np.arange(24).reshape(2,3,4)
>>> a
>>> a.shape #(2, 3, 4)
>>> b = np.transpose(a,axes=(0,2,1))
>>> b.shape #(2, 4, 3)
>>> b = np.transpose(a,axes=(2,0,1))
>>> b.shape #(4, 2, 3)
>>> b = np.transpose(a,axes=(1,2,0))
>>> b.shape #(3, 4, 2)
>>> np.transpose(a,axes=(0,2,2))#ValueError: repeated axis in transpose
```

>[!Note]
>* 1. For **1-D array, there is no impact of transpose() function**.  
>* 2. If we are **not using axes argument**, then **dimensions will be reversed**.  
>* 3. If we **provide axes argument**, then we can **specify our own order axes**.  
>* 4. Repeated axis in transpose is **not allowed**(0,2,2).  
>* 5. axes argument is more helpful from **3-D array onwards** but not for 2-array.  
>* 6. Various possible syntaxes:  
>		- np.transpose(a)  
>		- np.transpose(a,axes=(2,0,1))  
>		- ndarray.transpose()  
>		- ndarray.T  
>		- ndarray.transpose(*axes)  

ndarray class transpose() method:
------------
```py
>>> help(np.ndarray.transpose)
		a.transpose(*axes)
		Returns a view of the array with axes transposed.

>>> a = np.arange(24).reshape(2,3,4)
>>> a.shape #(2, 3, 4)
>>> b = a.transpose()
>>> b.shape #(4, 3, 2)
>>> b = a.transpose((2,0,1))
>>> b.shape #(4, 2, 3)
>>> b = a.T 
>>> b.shape #(4, 3, 2)
```
##### Day-11 [6-03-2025]

swapaxes():
--------
input:(2,3,4) :  
output:(4,3,2)/(3,2,4)/(2,4,3)/(3,4,2) etc......

By transpose() function, we can interchange any number of dimensions.  
But if want to **interchange only two dimensions** then we should go for swapaxes().

swapaxes(a, axis1, axis2) --> Interchange two axes of an array.

a = (2,3,4)  
np.swapaxes(a,0,2) ---> (4,3,2)  
np.swapaxes(a,1,2) ---> (2,4,3)  

Ex:
```py
>>> a = np.arange(24).reshape(2,3,4)
>>> a
>>> a.shape #(2, 3, 4)
>>> b = np.swapaxes(a,0,2)
>>> b.shape #(4, 3, 2)
>>> b = np.swapaxes(a,1,2)
>>> b.shape #(2, 4, 3)
```
ndarray class also contains swapaxes:
-----------------------------------
```py
>>> help(np.ndarray.swapaxes)
	    a.swapaxes(axis1, axis2)
	    Return a view of the array with `axis1` and `axis2` interchanged.

>>> a.shape #(2, 3, 4)
>>> b = a.swapaxes(0,1)
>>> b.shape #(3, 2, 4)
```
Q. Difference between transpose() and swapaxes()?
----------------------------------------------
By using transpose() we can **interchange any number of dimensions**.  
By using swapaxes() we can **interchange only two dimensions**.  

Joining of multiple ndarrays into a single array
=========================================
It is something similar to line join queries in Oracle.

* 1. concatenate()
* 2. stact()
* 3. vstack()
* 4. hstack()
* 5. dstack()

1: concatenate()
-----------------------
```py
>>> help(np.concatenate)

concatenate((a1, a2, ...), axis=0, out=None, dtype=None, casting="same_kind")
Join a sequence of arrays along an existing axis.
```
2-D array + 2-D array
--------------------------------
* axis=0(default): **vertical** concatenation will happens  
* axis=1: **Horizontal** concatenation will happens  
* axis=**None**  

**These 2-D arrays will be flatten to 1-D array and then concatenation will happens**

```py
>>> a = np.array([[1,2],[3,4]])
>>> b = np.array([[5,6],[7,8]])
>>> a
>>> b
>>> np.concatenate((a,b))
>>> np.concatenate((a,b),axis=0)
>>> np.concatenate((a,b),axis=1)
>>> np.concatenate((a,b),axis=None)
```
Rules :
---------
1.We can **join any number of arrays**, but all arrays **should be same dimension**.  
2.The size of **all axes must be matched,except concatenation axes.**  
	(2,3) 
	(5,3)  
3.The result of concatenation and output have the same shape.  

Concatenation of two 1-D arrays:
-------------------------------
Ex-1
```py
>>> a = np.arange(4)
>>> a
>>> b = np.arange(5)
>>> b
>>> np.concatenate((a,b))
>>> c = np.arange(3)
>>> c
>>> np.concatenate((a,b,c))

# Storing result out parameter

>>> d = np.zeros(12,dtype=int)
>>> d
>>> np.concatenate((a,b,c),out=d)
>>> d
>>> d = np.empty(12,dtype=int)
>>> np.concatenate((a,b,c),out=d)
>>> d

# Using dtype parameter:
# We can specify the required type by using dtype parameter

>>> np.concatenate((a,b,c),dtype='float')
>>> np.concatenate((a,b,c),dtype='str')

#Note:
#	We cannot use dtype and out simultaneously, because out array has its own dtype.

>>> c = np.empty(9)
>>> np.concatenate((a,b),out=c,dtype='int')
TypeError: concatenate() only takes `out` or `dtype` as an argument, but both were provided.
```
Joining of 2-D arrays :
---------------------
* For 2-D array the existing axes are:  
	* axis-0 ---> Represents the **number of rows**  
	* axis-1 ---> Represents **number of columns**  

* We can perform concatenation based on **either axis-0 or axis-1.**
* The **size of all dimensions(axes) must be matched except concatenation axis.**  
* If we are not specifying axis the **default value is 0.**  
* If axis is None, **then arrays will be flatten to 1-D array** and then **concatenation will be happend.**

Ex-1
```py
>>> a = np.array([[10,20],[30,40],[50,60]])
>>> b = np.array([[70,80],[90,100]])
>>> a
>>> np.concatenate((a,b))
>>> np.concatenate((a,b),axis=1)#Invalid
>>> np.concatenate((a,b),axis=None)
```
Ex-2:
```py
>>> a = np.arange(6).reshape(3,2)
>>> a.shape #(3, 2)
>>> b = np.arange(9).reshape(3,3)
>>> b.shape #(3, 3)
>>> np.concatenate((a,b),axis=0) #Not possible
>>> np.concatenate((a,b),axis=1)
>>> np.concatenate((a,b),axis=None)
```

Concatenation of 3-D arrays :
-----------------------------
(x,y,z)

* axis-0-->The number of **2-D array**
* axis-1-->The number of **rows in every 2-D array**
* axis-2-->The number of **columns in every 2-D array**

Ex-1:  
a = (2,2,2)
b = (2,2,2)

```py
>>> a = np.arange(8).reshape(2,2,2)
>>> b = np.arange(8).reshape(2,2,2)
>>> np.concatenate((a,b),axis=0)
>>> np.concatenate((a,b),axis=1)
>>> np.concatenate((a,b),axis=None)
```
Ex-2:

	a = (2,3,2)
	b = (2,3,3)

	axis-0--->no  
	axis-1--->no  
	axis-2---yes  

	Q. a:(2,3,3) and b:(1,3,3)  
	axis-0 only possible

	Q. (3,2,3) and (2,1,3)
	Not possible to perform concatenation on any axis
	But axis=None is possible

##### Day-12 [7-03-2025]

Joining of multiple arrays by using stack() function:
-----------------------------------------------------
1-D + 1-D --->2-D  
2-D + 2-D --->3-D

	Rules:
		The input array must have same shape.
		The resultant stacked array has one more dimension than the input array
		Joining will happen along new axis of newly created array.

Stacking of 1-D array:
----------------------
```py
>>> a = np.array([10,20,30])
>>> b = np.array([40,50,60,70])
>>> np.stack(a,b) #Invalid

>>> a = np.array([10,20,30])
>>> b = np.array([40,50,60])
>>> np.stack((a,b))
>>> np.stack((a,b),axis=0)
>>> np.stack((a,b),axis=1)
```
stacking of 2-D array:
---------------------
```py
# The resultant array will be : 3-D array
# 3-D array shape:(x,y,z)
# x--->axis-0
# y--->axis-1
# z--->axis-2

>>> a = np.array([[1,2,3],[4,5,6]])
>>> b = np.array([[7,8,9],[10,11,12]])
>>> np.stack((a,b),axis=0)
>>> np.stack((a,b),axis=1)
>>> np.stack((a,b),axis=2)

Ex:
>>> a = np.arange(1,7).reshape(3,2)
>>> b = np.arange(7,13).reshape(3,2)
>>> c = np.arange(13,19).reshape(3,2)
>>> np.stack((a,b,c),axis=0)Q.What i
>>> np.stack((a,b,c),axis=1)
>>> np.stack((a,b,c),axis=2)
```
Stacking Three 1-D array
------------------------
```py
>>> a = np.arange(4)
>>> b = np.arange(4,8)
>>> c = np.arange(8,12)
>>> np.stack((a,b,c),axis=0)
>>> np.stack((a,b,c),axis=1)
```
Q. What is the difference between concatenate() and stack()?
---

|Feature |numpy.concatenate()|numpy.stack()|
|:-----------|:--------|:---------|
|Dimensionality|The output array has the **same number of dimensions** as the input arrays.|The output array has **one more dimension** than the input arrays.|
|Input Shape|Input arrays must have the **same shape, except for the axis you are joining on**.|All input arrays **must have the exact same shape**.|
|Joining Behavior|Combines arrays by appending their data to one another along a specified axis.|Joins arrays by introducing a new axis and placing the input arrays along that axis.|

3.vstack():
----------------
vstack ---> vertical stack ---> joining is **always based on axis-0**  
For 1-D arrays ----> 2-D array is output.  
For 1-D array the **size must be same**.  
The result of vstack() function should be atleast 2-D.  

Ex-1

```py
>>> a = np.array([10,20,30,40])
>>> b = np.array([50,60,70,80])
>>> np.vstack((a,b))
```
Ex-2
```py
>>> a = np.arange(1,10).reshape(3,3)
>>> b = np.arange(10,16).reshape(2,3)
>>> a
>>> b
>>> np.vstack((a,b))
```
Ex:
```py
>>> a = np.arange(1,10).reshape(3,3)
>>> b = np.arange(10,16).reshape(3,2)
>>> np.vstack((a,b))#Not possible
```
For 3-D arrays:
---------------
**axis-0 means the number of 2-D arrays**
```py
>>> a = np.arange(1,25).reshape(2,3,4)
>>> b = np.arange(25,49).reshape(2,3,4)
>>> np.vstack((a,b))
```
Joining of arrays by using hstack() function:
---------------------------------------------
hstack ---> horizontal stack ----> column wise  
1-D + 1-D ---> 1-D

For 1-D array:
--------------
```py
>>> a = np.array([10,20,30])
>>> b = np.array([40,50,60])
>>> np.hstack((a,b))
array([10, 20, 30, 40, 50, 60])
```
For -2D array:
--------------
```py
>>> a = np.arange(1,7).reshape(3,2)
>>> b = np.arange(7,16).reshape(3,3)
>>> np.hstack((a,b))

>>> a = np.arange(1,7).reshape(2,3)
>>> b = np.arange(7,16).reshape(3,3)
>>> np.hstack((a,b))#not possible
```
joining of arrays by using dstack():
-------------------------------------
dstcak means ---> depth stack / height stack **based on axis-2.**  
1-D and 2-D arrays will be converted to 3-D array.  
The result **is minimum 3-D array**

Ex:
```py
>>> a = np.array([1,2,3])
>>> b = np.array([2,3,4])
>>> np.dstack((a,b))
```
Ex:
```py
>>> a = np.array([[1],[2],[3]])
>>> b = np.array([[2],[3],[4]])
>>> np.dstack((a,b))
```
Summary of joining nd arrays:
------------------------------
>[!Note]  
1.concatenate() ==> Join a sequence of arrays **along existing axis**.  
2.stack() ==> Join a sequence of arrays **along a new axis**.  
3.vstack() ==> Stack arrays in sequence **vertically according to axis-0**.  
4.hstack() ==> Stack arrays in sequence **horizontally according to axis-1**.  
5.dstack() ==> Stack arrays in sequence **depth wise according to axis-2**.  

Splitting of ndarrays:
----------------------
- 1). split()
- 2). vsplit()
- 3). hsplit()
- 4). dsplit()
- 5). array_split()

**Above methods returns views but not copies.**

1). split():
-----------
```py
>>> help(np.split)
split(ary, indices_or_sections, axis=0)
    Split an array into multiple sub-arrays as views into `ary`.
```
sections:  
	1.Array will be splitted into **sub arrays of equal size**.  
	2.It returns list of sub arrays.  

To split 1-D array into 3-parts
-------------------------------
```py
>>> a = np.arange(1,10)
>>> np.split(a,3)
>>> sub_arrays = np.split(a,3)
>>> sub_arrays[0] #array([1, 2, 3])
>>> sub_arrays[1] #array([4, 5, 6])
>>> sub_arrays[2] #array([7, 8, 9])
>>> sub_arrays = np.split(a,4)#array split does not result in an equal division
```
Splitting of 2-D array:
-----------------------
splitting is based on **axis-0 by default**. i.e row wise split **(vertical split)**  
we can also split based on **axis-1**. i.e column wise split **(horozintal split)**

Splitting based on axis-0 [ vertical split (default split) ] :
--------------------------

```py
>>> a = np.arange(1,25).reshape(6,4)
>>> a
>>> np.split(a,3)
>>> np.split(a,2)
>>> np.split(a,6)
>>> np.split(a,4)#Not possible
```
Splitting based on axis-1 [horizonatal split]:
--------------------------
axis-1 means column wise splitting (horizontal split).

```py
>>> a = np.arange(1,25).reshape(6,4)
>>> np.split(a,2,axis=1)
>>> np.split(a,4,axis=1)
>>> np.split(a,3,axis=1)#Not possible
```


------
>[!Note]
>Numpy Sum Explanation other sources link  
>ToDo -- move to apporoprita location, where numpy sum is explained.  
>[Numpy Sum explanation](https://medium.com/data-science/understanding-numpy-sum-1587eec69527)
------

##### Day-13 [8-03-2025]

Splitting based on indices:
----------------------------
The sizesof sub arrays **need not be equal**.

Ex:
```py
>>> a = np.arange(10,101,10)
>>> a 
>>> np.split(a,[3,7])
>>> np.split(a,[2,5,7])
```
Split 2-D array based on indices:
---------------------------------
```py
>>> a = np.arange(1,13).reshape(6,2)
>>> a
>>> np.split(a,[3,4])
>>> np.split(a,[1,3,4])

>>> a = np.arange(1,19).reshape(3,6)
>>> a
>>> np.split(a,[1,3,5],axis=1)
>>> np.split(a,[2,4,4],axis=1)
>>> np.split(a,[0,2,6],axis=1)
>>> np.split(a,[1,5,3],axis=1)
```
Splitting by using vsplit():
----------------------------
vsplit means vertical split **means row wise split**, is based on axis-0.  
To use vsplit, input array should be **atleast 2-D array**.
```py
>>> help(np.vsplit)
		vsplit(ary, indices_or_sections)

# To use vsplit, input array should be atleast 2-D array.

>>> a = np.arange(10)
>>> a
>>> np.vsplit(a,2)
ValueError: vsplit only works on arrays of 2 or more dimensions
```
vsplit - For 2-D array:
--------------
```py
>>> a = np.arange(1,13).reshape(6,2)
>>> a
>>> np.vsplit(a,2)
>>> np.vsplit(a,3)
>>> np.vsplit(a,6)
>>> np.vsplit(a,[1,4]) #base on indices
```
Splitting by using hsplit():
----------------------
split horizontally(column wise)
```py
>>> a = np.arange(10)
>>> a
>>> np.hsplit(a,2)
>>> np.hsplit(a,5)
>>> np.hsplit(a,3)#Error
```
hsplit - For 2-D array:
--------------
Based on axis-1 only
```py
>>> a = np.arange(1,13).reshape(3,4)
>>> a
>>> np.hsplit(a,2)
>>> np.hsplit(a,4)
>>> np.hsplit(a,3)#Error
```
hsplit based on indices:
------------------------
```py
>>> a = np.arange(10,101,10)
>>> a
>>> np.hsplit(a,[2,4,7])

>>> a = np.arange(24).reshape(4,6)
>>> a
>>> np.hsplit(a,[2,4])
>>> np.hsplit(a,[1,4])
```
>[!Note]
> - vsplit() ---> split based on **axis-0(row)**
> - hsplit() ---> split based on **axis-1(column)**
> - dsplit() ---> split based on **axis-2 ---> 3-D array**

Splitting using dsplit():
-------------------------
```py
>>> help(np.dsplit)
		dsplit(ary, indices_or_sections)
			Split array into multiple sub-arrays along the 3rd axis (depth).

>>> a = np.arange(24).reshape(2,3,4)
>>> a
>>> np.dsplit(a,2)
>>> np.dsplit(a,[1,3]) # dsplit based on indices
```

##### Day-14 [10-03-2025]

Split using array_split():
------------------------
The numpy.array_split() function splits an array into multiple sub-arrays along a specified axis.  

Its main advantage over the standard numpy.split() is that it **allows for uneven divisions without raising an error**.

array_split()  -->  sections **need not be to have equal size** 

split() with sections ---> **Should be equal parts**, otherwise ---> error 

4 --> rows ----> 3 equal parts

```py
>>help(np.array_split()
array_split(ary, indices_or_sections, axis=0)
    Split an array into multiple sub-arrays.
```
For an array of length **x** that should be split into **n** sections,  
It returns 
- **x % n sub-arrays of size (x//n)+1** 
- **and rest of size x//n**

```py
#Ex-1
# 10 elements ---> 3 sections  

#	x = 10		n = 3  

# x % n number of sub-arrays of size : (x//n)+1 ===> 1 number of sub-array of size: 4  

# rest of size x//n ==> 2 number of sub-arrays of size : 3  


>>> a = np.arange(10,101,10)
>>> a
>>> np.array_split(a,3)

#Ex-2
# 11 elements ---> 3 sections 

#	11-elements			3-sections

# x % n number of sub-arrays of size : (x//n)+1 ===> 2 sub-array of size : 4
# rest of size x//n==>1 sub-arrays of size : 3

(4,4,3)

>>> a = np.arange(0,101,10)
>>> a
>>> np.array_split(a,3)
```
Summary of split methods:
-------------------------
>[!Note]
> - split() : Split an array into multiple sub-arrays of **equal size**.  
> - vsplit() : Split an array into multiple sub-arrays **vertically(row wise).**  
> - hsplit() : Split an array into multiple sub-arrays **horizontally(column wise).**  
> - dsplit() : Split an array into multiple sub-arrays along the **3rd axis(depth).**  
> - array_split() : Split an array into multiple sub-arrays of equal or near-equal size & **Does not raise an exception** if an equal division cannot be made.  

Sorting of ndarrays:
--------------------
```py
>>> help(np.sort)
			quicksort    -->merge sort ,heap sort
```
The default is **'quicksort'**  
For numbers --> **Ascending order**  
For strings ---> **Alphabatical order**  

1-D array
------------
```py
>>> a = np.array([20,10,5,40,30,50])
>>> a
>>> np.sort(a)
```
To sort in descending order
---------------------------
```py
# 1st way:
	>>> np.sort(a)[::-1]

# 2nd way:
	>>> a
	>>> -a
	>>> np.sort(-a)
	>>> -np.sort(-a)
```
To sort string elements in alphabatical order:
------------------------------------------
```py
>>> a = np.array(['sunny','bunny','vinny','chinny'])
>>> np.sort(a)
```
To sort reverse of alphabatical order:
--------------------------------------
```py
>>> np.sort(a)[::-1]
>>> -np.sort(-a) #Invalid
```
for 2-D array:
--------------
```py
>>> a = np.array([[40,20,70],[30,20,60],[70,90,80]])
>>> a
>>> np.sort(a,axis=0)
>>> np.sort(a,axis=-2)
```
Searching elements of ndarray using where():
------------------------------

where() function returns indices where condition is True, and does not returns elements.

```py
>>>help(np.where)
	where(...)
    where(condition, [x, y])

>>> a = np.array([3,5,7,6,9,4,6,10,15])
>>> a
```
Find indices where the value is 7
```py
>>> np.where(a==7)
```

Find indices where odd numbers present in array
```py
>>> np.where(a%2!=0)
```
To get elements directly
```py
>>>indices = np.where(a%2!=0)
>>>a[indices]
```
condition based selection using where():
----
where function can perform replace operation also.
>where(condition, [x, y]):  

If **condition satisfied that element will be replaced with x** and if the **condition fails that element will be replaced with y.**

Ex:
```py
>>> a
array([ 3,  5,  7,  6,  9,  4,  6, 10, 15])

# Replace even numbers with 333 and every odd number with 999
>>> np.where(a%2==0,333,999)
```
Replace odd numbers present in a (ndarray) with 333.
```py
>>> np.where(a%2!=0,333) #Invalid
>>> np.where(a%2!=0,333,a)
```
For 2-D array
-------------
```py
>>> a = np.arange(12).reshape(4,3)
>>> a
>>> np.where(a%5==0)
(array([0, 1, 3], dtype=int64), array([0, 2, 1], dtype=int64))
# The first ndarray represents row indices and second ndarray represents column indices.
# i.e required elements present at ((0,0),(1,2) and (3,1) index places.

# If we want to see the elements

>>> b = np.where(a%5==0)
>>> a[b]

# Even we can perform replacement operation also

>>> np.where(a%5==0,999,a)
```
searchsorted() function:
-----------------------
**Find indices** where elements should be inserted to maintain order.  
Internally this function uses **use binary search algorithm**.  
Hence we **can call this function only for sorted arrays**.  
If the array is not sorted then we will get abnormal results.
```py
searchsorted(a, v, side='left', sorter=None)
    Find indices where elements should be inserted to maintain order.

>>> a = np.arange(0,31,5)
>>> a
>>> np.searchsorted(a,5) #1
>>> np.searchsorted(a,13) #3
```

By default it will **always search from left hand side** to identify insertion point.  
If we want to search from right hand side we should use **side = 'right'.**

```py
>>> a = np.array([3,5,7,6,7,9,4,10,15,6])
>>> a = np.sort(a)
>>> a
>>> np.searchsorted(a,6)#3
>>> np.searchsorted(a,6,side='right') #5
```

>[!Note]
> - sort() ---> To sort given array.
> - where() ---> To perform search and replace operation.
> - searchsorted() ---> To identify insertion point in the given sorted array.

##### Day-1 [27-02-2025]
# Python for Data Science, ML, DL and AI:
Devops --> Regular core python knowledge concise code  
Rich libraries --->70 to 90% our libraries 10% we have to write the code.

## What is this line in python?
```python
import numpy as np
# Numpy-->Entry point from python for DS
# Numpy-->Numerical Python Library
```
## How to install Numpy?
```python
>>>pip install numpy
```

## How to check version:
```python
D:\Mahesh_Classes>py
>>> import numpy as np
>>> np.__version__
```
## What is the need of Numpy?
Python performs basic mathematical operations.

```python
a = 10
b = 20
a+b
a-b
a/b
a*b

math.sqrt(4)
```
But in Data Science, ML, DL and AI required complex matghematical operations....

* 1. Numpy defines several functions to perform **complex mathematical operations**.
* 2. To fullfill performance gaps most of the Numpy is **implemented in C-Language** superfast
* 3. nd array(To store large data in nd array for matplotlib graph style) -->n dimensional array or numpy array

```py
# Ex:
# matrix with all zero 10X10 shape
# l = [[0,0,0,0...],[],[],......[]]

	>>>import numpy as np
	>>>a = np.zeros((10,10))
	>>>a

# If you want only int type:
	>>> a = np.zeros((10,10),dtype=int)

# list of 100-numbers:
	>>>a = np.arange(1,101)
	>>>a

# pls convert into 2-dimension array
	>>>a.reshape(10,10)

# Identity matrix?
	>>>a = np.identity(3)
	>>>a = np.identity(5)
```
* 4. Data Analysis:  
     2 crore samples are analyzed  
     100 -->points  
     new patient--->corona  

## History of Numpy:
Origin of Numpy---->Numeric Library  
Numeric Library--->**Jim Hugunin**  
Numpy-->**Travis Oliphant(2005)**  
Open source library and freeware  

## Q.In which language Numpy was written?  
**C and Python**

## Q.What is nd array in numpy?
The fundamental data type to store our data : nd array
```python
>>> a = np.identity(5)
>>> type(a) #<class 'numpy.ndarray'>
>>> help(np.ndarray)
Help on class ndarray in module numpy:
arrays are objects of ndarray class present in numpy module
```
Array: An indexed collection of homogenious elements

1-D array	---> Vector  
2-D array	---> Matrix  
.  
.  
.  
n-D array	---> No name  

#### Day-1 https://youtu.be/z2Hq-8-fWrY

##### Day-2 [27-02-2025] 
# Numpy Basic Introduction

## Ex: What is the need of Numpy
```py
Boys and Girls are attending Mahesh sir datascience class.
For boys fee is $3 and for girls fees is $8, For a certain batch 2200 people attended and $10100 fee collected. How many boys and girls attended for that batch.

x --->no of boys
y --->no of girls

x + y = 2200
3x + 8y = 10100

coefficient matrix:
a =	1 1
	3 8
value matrix
b = [2200,10100]

numpy.linalg.solve(a,b)

>>> import numpy as np
>>> a = np.array([[1,1],[3,8]])
>>> a
array([[1, 1],
       [3, 8]])
>>> b = np.array([2200,10100])
>>> b
array([ 2200, 10100])
>>> np.linalg.solve(a,b)
array([1500.,  700.])
```
## Array:
An indexed collection of homogenious data elements.

## How to create arrays in python.
Inbuilt arrays concept is not there in python

### 2-ways:
* 1. By using array module
* 2. By using numpy module

### 1. By using array module (Not recommended)
```py
import array
a = array.array('i',[10,20,30])#i represents type:int array
print(type(a))
print(a)
print('Elements one by one:')
for x in a:
	print(x)

Note:
	array module is not recommended because much library support is not available.
```

###  2. By using numpy module:
```py
import numpy
a = numpy.array([10,20,30])
print(type(a))
print(a)
for x in a:
	print(x)
```
## Python's List vs Numpy ndarray:
### 1. Similarities:
* Both are used to store data.  
* The order will be preserved in both. Hence indexing and slicing concepts are applicable.  
* Both are mutable, i.e we can change the content.  

### 2. Differences:
* list is pythons inbuilt type. We have to install and import numpy explicitly.
* list can contain hetrogenious elements. But array contains only homogenious elements.
```py
import numpy
l = [10,10.5,'Sunny',True]
print(l)#[10, 10.5, 'Sunny', True]
a = numpy.array(l)
print(a)#['10' '10.5' 'Sunny' 'True']
```
* On list we cannot perform vector operations. But on ndarray we can perform vector operations
```py
>>>l = [10,20,30,40]
>>>import numpy as np
>>>a = np.array(l)
>>>a #array([10, 20, 30, 40])
>>>l + 2 #Invalid
>>>a + 2 #array([12, 22, 32, 42])
>>>a / 2 #array([ 5., 10., 15., 20.])
>>>l * 2 #[10, 20, 30, 40, 10, 20, 30, 40]
>>>a * 2 #array([20, 40, 60, 80])
```
* Arrays consumes less memory than list.
* Array are superfast when compared with list.
* Numpy arrays are more convinient to use while performing complex mathematical operations.

## How to create Numpy Arrays:
* 1. array()
* 2. arange()
* 3. linspace()
* 4. zeros()
* 5. ones()
* 6. full()
* 7. eye()
* 8. identity()
* 9. empty()
* 10. numpy.random
 	* 1. randint()
 	* 2. arnd()
 	* 3. uniform()
 	* 4. randn()
  	* 5. normal()
  	* 6. shuffle()  

### 1. Creation of numpy arrays by using array():
```py
## For the given list or tuple
>>>import numpy as np
>>>help(np.array)

## 1-D array:
>>> l = [10,20,30]
>>> type(l)#<class 'list'>
>>> a = np.array(l)
>>> type(a)#<class 'numpy.ndarray'>
>>> a #array([10, 20, 30])
>>> a.ndim #1
>>> a.dtype #dtype('int32')

## Note:
	a.ndim--->To know dimension of ndarray
	a.dtype--->To know data type of elements

## 2-D array creation:
[[10,20,30],[40,50,60],[70,80,90]]----->Nested List

>>> a = np.array([[10,20,30],[40,50,60],[70,80,90]])
>>> type(a) #<class 'numpy.ndarray'>
>>> a
>>> a.shape #(3, 3)
>>> a.ndim #2
>>> a.size #9

## To create 1-D array from the tuple
>>> a = np.array(('sunny','bunny','vinny'))
>>> a.ndim #1
>>> a.shape #(3,)
>>> a.dtype #dtype('<U5')

Note:Array contains only homogenious elements.
If the list contains hetrogenious elements:Upcasting will be performed.

>>> a = np.array([10,20,10.5])
>>> a #array([10. , 20. , 10.5]) Upcasting int to float
>>> a.dtype #dtype('float64')

>>> a = np.array([10,20,'a'])
>>> a #array(['10', '20', 'a'], dtype='<U11')

## How to create a particular type:
We have to use dtype parameter

>>> a = np.array([10,20,30.5],dtype=int)
>>> a #array([10, 20, 30])
>>> a = np.array([10,20,30.5],dtype=bool)
>>> a #array([ True,  True,  True])
>>> a = np.array([10,20,30.5],dtype=float)
>>> a #array([10. , 20. , 30.5])
>>> a = np.array([10,20,30.5],dtype=complex)
>>> a #array([10. +0.j, 20. +0.j, 30.5+0.j])

>>> a = np.array([10,'Sunny'],dtype=int) #Invalid

## How to create object type array:
Here any type of elements are allowed.

>>> a = np.array([10,'Sunny',True,10.5,10+3j],dtype=object)
>>> a #array([10, 'Sunny', True, 10.5, (10+3j)], dtype=object)

If we are not given dtype then
>>> a = np.array([10,'Sunny',True,10.5,10+3j])
>>> a #array(['10', 'Sunny', 'True', '10.5', '(10+3j)'], dtype='<U64')

array() ----> To create ndarray from the given list or tuple.
```
#### Day-2 https://youtu.be/uHsowtczZ3Y

# Day-3

### 2. Creation of ndarray by using arange() function:
```py
Python:
	range(10)==>0 to 9
	range(1,11)==>1 to 10
	range(1,11,2)==>1,3,5,7,9

>>> import numpy as np
>>> help(np.arange)
			
		 arange([start,] stop[, step,], dtype=None, *, like=None)

## Ex-1:create 1-D array 0 to 9
>>> a = np.arange(10)
>>> a #array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
>>> a.ndim #1
>>> a.shape #(10,)
>>> a.dtype #dtype('int32')
>>> a = np.arange(1,11)
>>> a #array([ 1,  2,  3,  4,  5,  6,  7,  8,  9, 10])
>>> a = np.arange(1,11,2)
>>> a #array([1, 3, 5, 7, 9])
>>> a = np.arange(1,11,3,dtype=float)
>>> a #array([ 1.,  4.,  7., 10.])
```
### 3. Creation of numpy arrays by using linspace() function:
```py
	In the specified interval, linearly spaced values.
>>>help(np.linspace)
linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None, axis=0)
	 Return evenly spaced numbers over a specified interval.

Ex:
>>> np.linspace(0,1,2) #array([0., 1.])
>>> np.linspace(0,1,3) #array([0. , 0.5, 1. ])
>>> np.linspace(0,1,4) #array([0. , 0.33333333, 0.66666667, 1. ])
>>> np.linspace(0,1)
>>> np.linspace(0,1).size #50
>>> np.linspace(0,1).shape #(50,)
>>> np.linspace(1,100,10,dtype=int) #array([1,12,23,34,45,56,67,78,89,00])

1 to 12--->11 numbers
12 to 23--->11 numbers
equally spaced values
```
### arange() vs linspace():
* arange() --> Elements will be considered in the given range based on step value.
* linspace() --> The specified number of values will be considered in the given range.

### 4. Creation of numpy arrays by using zeros() function:
```py
(10,)--->1-D array contains 10-elements

(5,2)--->2-D array contains 5-rows and 2-columns
			2-D array means collection of 1-D arrays

(2,3,4)--->3-D array
			3-D array contains a collection of 2-D arrays
			2--->2 number of 2-D arrays
			3--->The number of rows in every 2-D array
			4-->The number of columns in every 2-D array
			size:24
			
>>>help(np.zeros)
		 zeros(shape, dtype=float, order='C', *, like=None)

>>> np.zeros(4) #array([0., 0., 0., 0.])
>>> np.zeros((4,)) #array([0., 0., 0., 0.])
>>> np.zeros((4,3))
>>> np.zeros((2,3,4))
>>> np.zeros((1,3,2))

-->Perform some operations the result we have to store somewhere.
```

### 5. Creation of numpy arrays by using ones() function:
```py
Exactly same as zeros except that instead of zero array filled with 1.
fill_value:1

>>> help(np.ones)
		ones(shape, dtype=None, order='C', *, like=None)
			Return a new array of given shape and type, filled with ones.
## Ex:
>>> np.ones(10)
>>> np.ones((4,2))
>>> np.ones((4,2),dtype=int)
>>> np.ones((2,3,4),dtype=int)
```
### 6. Creation of numpy arrays by using full() function:
```py
>>> help(np.full)
		full(shape, fill_value, dtype=None, order='C', *, like=None)
			 Return a new array of given shape and type, filled with `fill_value`.

>>> np.full(10) #full() missing 1 required positional argument: 'fill_value'
>>> np.full(10,2)
>>> np.full(10,3)
>>> np.full((5,4),9)
>>> np.full((2,3,4),6)

Note:
	1). np.full(shape=(5,4),fill_value=3)
	2). np.full((5,4),fill_value=3)
	3). np.full((5,4),3)
	4). np.full(shape=(5,4),3)#positional argument follows keyword argument
```
### 7. Creation of numpy arrays by using eye() function:
```py
>>>help(np.eye)
eye(N, M=None, k=0, dtype=<class 'float'>, order='C', *, like=None)
    Return a 2-D array with ones on the diagonal and zeros elsewhere.

N--->Number of rows
M--->Number of columns
K--->Meant for diagonal
0 1 2 3 4
-1
-2
-3
-4

Ex:
>>> np.eye(2,3)
>>> np.eye(3,dtype=int)
>>> np.eye(5,dtype=int)
>>> np.eye(5,k=1,dtype=int)
>>> np.eye(5,k=-3,dtype=int)
```
### 8. Creation of numpy arrays by using identity() function:
```py
It is exactly same as eye() function except that
	1). It is always square matrix(the number of rows and number of columns always same)
	2). Only main diagnol contains 1's

identity() is a special case of eye()

>>>help(np.identity)
identity(n, dtype=None, *, like=None)
    Return the identity array.

Ex:
>>> np.identity(5)
>>> np.identity(5,dtype=int)
```
### 9. Creation of numpy arrays by using empty() function:
```py
>>>help(np.empty)
		empty(shape, dtype=float, order='C', *, like=None)
    Return a new array of given shape and type, without initializing entries.

Ex:
>>> np.empty(3)
>>> np.empty((3,3))
>>> np.empty(10)
```
### zeros() vs empty():
* If we required an array only with zeros then we should go for zeros()
* If we never worry about data, just we required an empty array for future purpose, then we should go for empty().
* The time required to create empty array is very very less when compared with zeros array.
  i.e **performance wise empty function is recommended than zeros if we are not worry about data.**
```py
#Performace comparisiob of zeros() and empty()
import numpy as np
from datetime import datetime
begin = datetime.now()
a = np.zeros((10000,300,400))
after = datetime.now()
print('Time taken by zeros:',after-begin)
a = None
begin = datetime.now()
a = np.empty((10000,300,400))
after = datetime.now()
print('Time taken by empty:',after-begin)
```
#### Day-3 https://youtu.be/rq0BWe2wYSY

##### Day-4:

## 10. Array creation by using random module:
* randint()
* rand()
* uniform()
* randn()
* normal()
* shuffle()

### 1. randint():
```py
	To generate random int values in the given range.

>>> import numpy as np
>>> help(np.randint) #Error
>>> help(np.random.randint)
		randint(low, high=None, size=None, dtype=int)
	    Return random integers from 'low' (inclusive) to 'high' (exclusive).
		[low,high)

## Ex:
>>> np.random.randint(10,20)

## 1-D array
>>> np.random.randint(1,10,size=10)

## 2-D array
>>> np.random.randint(100,size=(3,5)) 

## 3-D array
>>> np.random.randint(100,size=(2,3,4))

Ex:
>>>  np.random.randint(1,10,size=10,dtype=float)
TypeError: Unsupported dtype dtype('float64') for randint

Syn:
	randint(low, high=None, size=None, dtype=int)

int8,int16,int32,int64

>>> a = np.random.randint(1,10,size=(20,30))
>>> a.dtype #int32
>>> a = np.random.randint(1,10,size=(20,30),dtype='int8')
>>> a.dtype #int8==> Memory utilization

Ex:
>>> import sys
>>> a = np.random.randint(1,10,size=(20,30))
>>> sys.getsizeof(a) #2528
>>> a = np.random.randint(1,10,size=(20,30),dtype='int8')
>>> sys.getsizeof(a) #728
```
### How to convert from one array type to another type

```py
We have to use astype() method

>>> a = np.random.randint(1,10,size=(20,30))
>>> a.dtype #dtype('int32')
>>> b = a.astype('float')
>>> b.dtype #dtype('float64')

### 2. rand():
```py
uniform distribution	---> 10 11 9 10 11 10
normal distribution	---> 6 4 10 4 14(10 is mean value)

It will generate random float values in the range [0,1) from uniform distribution samples.

Ex:
>>> np.random.rand() #A single float value will be generated

## 1-D array
>>> np.random.rand(10)

## 2-D array
>>> np.random.rand(3,5)

## 3-D array
>>> np.random.rand(2,3,4)
```
### 3. uniform():
```py
rand() ---> range is always [0,1)
uniform() ---> customize range
	uniform(low=0.0, high=1.0, size=None)

Ex:
>>> np.random.uniform()
>>> np.random.uniform(10,20)

1-D array: >>> np.random.uniform(10,20,size=5)
2-D array: >>> np.random.uniform(10,20,size=(3,4))
3-D array: >>> np.random.uniform(10,20,size=(2,3,2))
```
### 4. randn():
```py
	values from normal distribution with mean 0 and variance is 1

>>> np.random.randn(10)
>>> np.random.randn(2,3)
>>> np.random.randn(2,3,4)
```
### 5. normal():
```py
	We can customize mean and variance

	normal(loc=0.0, scale=1.0, size=None)

>>> np.random.normal(10,4,size=10)
>>> np.random.normal(10,4,size=(2,3,4))
```
### 6. shuffle():
```py
>>> help(np.random.shuffle)

## 1-D array:
>>> a = np.arange(9)
>>> a
>>> np.random.shuffle(a) #inline shuffling happens
>>> a

## 2-D array:
>>> a = np.random.randint(1,101,size=(6,5))
>>> a
>>> np.random.shuffle(a)
>>> a

## 3-D array:(4,3,4)
If we apply shuffle for 3-D array, then the order of 2-D arrays will be changed but not it's internal content

>>> a = np.arange(48).reshape(4,3,4)
>>> a
>>> np.random.shuffle(a)
>>> a
```
## Summary of random library functions:
* 1. randint() ==> To generate random int values in the given range.
* 2. rand() ==> To generate uniform distributed float values in [0,1)
* 3. uniform() ==> To generate uniform distributed float values in the given range.[low,high
* 4. randn() ==> normal distributed float values with mean 0 and standart deviation 1.
* 5. normal() ==> normal distributed float values with specified mean and standard deviation.
* 6. shuffle() ==> To shuffle order of elements in the given nd array.

## Array attributes:
* 1. ndim ===>returns the dimension of the array
* 2. shape===>returns the shape of the array.(10,):1-D, (10,3):2-D
* 3. size===>To get total number of elements.
* 4. dtype===>To get data type of elements of the array.
* 5. itemsize===>Length of each element of array in bytes(4-bytes)
```py
## Ex:
>>> a = np.array([10,20,30,40])
>>> a.ndim #1
>>> a.shape #(4,)
>>> a.size #4
>>> a.dtype #dtype('int32')
>>> a.itemsize #4

## Ex:
>>> a = np.array([[10,20,30],[40,50,60],[70,80,90]],dtype='float')
>>> a.ndim #2
>>> a.shape #(3, 3)
>>> a.size #9
>>> a.dtype #dtype('float64')
>>> a.itemsize #8
```
#### Day-4 https://youtu.be/TpozMOoNwoU

##### Day-5: 
# Numpy Data Types:

**Python data types:** int,float,str,complex,bool etc.......

**Numpy data types:** Multiple data types present(Python + C)

* i===>integer(int8,int16,int32,int64)
  ```py
  int8==>i1;
  int16==>i2;
  int32==>i4 (default)
  ```
* b===>boolean
* u===>unsigned integer(uint8,uint16,uint32,uint64)
* f===>float(float16,float32,float64)
  ```py
  float16==>f2;
  float32==>f4(default);
  float64==>f8
  ```
* c===>complex(complex64,complex128)
* s==>String
* U==>Unicode String
* M===>datetime etc.....

### int8:
-->The value will be represented by 8bits.  
-->MSB is reserved for sign  
-->The range:-128 to 127  
```py
import sys
import numpy as np
a = np.array([10,20,30,40])
print(sys.getsizeof(a))
a = np.array([10,20,30,40],dtype='int8')
print(sys.getsizeof(a))
```
## Changing the data type of an existing array
* 1) astype()
* 2) By using built-in function of numpy like float64()
```py
Ex:
import numpy as np
a = np.array([10,20,30,40])
b = a.astype('float64')
print(a.dtype)#int32
print(b.dtype)#float64

Ex:
a = np.array([10,20,30,40])
b = np.float64(a)
print(a.dtype)
print(b.dtype)

Ex:
a = np.array([10,0,30,0])
x = np.bool(a)#Invalid

x = np.bool_(a)
print(x)
```
## How to get/access elements of Numpy Array:
* 1. Indexing
* 2. Slicing
* 3. Advanced Indexing

### 1.Indexing:
By using index, we can get single element of the array.  
zero based indexing. i.e the index of first element is 0  
supports both +ve and -ve indexing  

```py
## From 1-D array:
a[index]
>>> a = np.array([10,20,30,40])
>>> a #array([10, 20, 30, 40])
>>> a[0] #10
>>> a[-1] #40
>>> a[10] #IndexError

## From 2-D array:
a[rowindex][columnindex]

>>> a = np.array([[10,20,30],[40,50,60]])
>>> a
array([[10, 20, 30],
       [40, 50, 60]])

## To Access 50
>>> a[1][1]
>>> a[1][-2]
>>> a[-1][-2]
>>> a[-1][1]

## From 3-D array:
(2,3,4)
	a[i][j][k]:
		i-->represents which 2-D array(index of 2-D array)
		j-->represents row index in that 2-D array
		k-->represents column index in that 2-D array

a[0][1][2]:
	0-indexed 2-D array
	In that 2-D array 1 indexed row and 2 indexed column

>>> l = [[[1,2,3],[4,5,6],[7,8,9]],[[10,11,12],[13,14,15],[16,17,18]]]
>>> a = np.array(l)
>>> a

## To access 14:
>>> a[1][1][1]
>>> a[-1][-2][-2]
>>> a[1][-2][-2]
>>> a[-1][1][-2]
```
### 2. Slicing : Accessing elements of ndarray by using slice operator:
a[begin:end:step]
```py
## 1-D array:
>>> a = np.arange(10,101,10)
>>> a
>>> a[2:5]
>>> a[::1]
>>> a[::-1]
>>> a[::-2]

## 2-D array:
a[row,column]
a[begin:end:step, begin:end:step]

>>> a = np.array([[10,20],[30,40],[50,60]])
>>> a
array([[10, 20],
       [30, 40],
       [50, 60]])

## Access [10, 20]
>>> a[0:1,:]

>>> a[0,:]
array([10, 20])#It is 1-D array

>>> a[0::2,:]
array([[10, 20],
       [50, 60]])

>>> a[0:2,1:2]
array([[20],
       [40]])

>>> a[:2,1:]
array([[20],
       [40]])

## Ex:
>>> a = np.array([[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]])
>>> a
array([[ 1,  2,  3,  4],
       [ 5,  6,  7,  8],
       [ 9, 10, 11, 12],
       [13, 14, 15, 16]])

>>> a[0:2,:]
array([[1, 2, 3, 4],
       [5, 6, 7, 8]])

>>> a[0::3,:]
array([[ 1,  2,  3,  4],
       [13, 14, 15, 16]])

>>> a[:,0:2]
array([[ 1,  2],
       [ 5,  6],
       [ 9, 10],
       [13, 14]])

>>> a[:,::2]
array([[ 1,  3],
       [ 5,  7],
       [ 9, 11],
       [13, 15]])

>>> a[1:3,1:3]
array([[ 6,  7],
       [10, 11]])

>>> a[::3,::3]
array([[ 1,  4],
       [13, 16]])
```
#### Day-5 https://youtu.be/N3mXkipScMU

##### Day-6 [28-02-2025]
Slice in 3-D array:
---
(2,3,4)  
(i,j,k)  

2 --> number of 2-D arrays  
3 --> the number of rows  
4 --> the number of columns  

	a[i,j,k]  
	a[begin:end:step,begin:end:step,begin:end:step]

```py
l = [[[1,2,3,4],
	[5,6,7,8],
	[9,10,11,12]],
	[[13,14,15,16],
	[17,18,19,20],
	[21,22,23,24]]]
>>> a = np.array(l)
>>> a
>>> a[:,:,0:1]
>>> a[:,0:1,:]
>>> a[:,::2,:]
>>> a[:,:2,1:3]
>>> a[:,::2,::3]
```
>[!Note]
>To use slice operator, compulsory elements should be in order. We cannot select elements which are out of order. i.e we cannot select arbitrary lements.  

## Advanced Indexing:

By using index, **we can access only one elment at a time**.  

	a[i], a[i][j], a[i][j][k]

By using slice operator **we can access multiple elements at a time**, but all elements should be in order.  

	a[begin:end:step]  
	a[begin:end:step,begin:end:step]  
	a[begin:end:step,begin:end:step,begin:end:step]  

## Accessing multiple arbitrary elements:

Access elements of 1-D array:
---

	1-D array:  
		array[x]:  
		x can be either nd array or list, which represents required indexes.


```py
>>> a = np.arange(10,101,10)
>>> a #array([ 10,  20,  30,  40,  50,  60,  70,  80,  90, 100])

Required values are:[30,50,60,90]
---------------------------------------------------
1st way:
------------
create ndarray with required indices
>>>>>> indices = np.array([2,4,5,8])

pass this indices array as argument to original array
>>> a[indices] #array([30, 50, 60, 90])

2nd way:
-------------
>>> l = [2,4,5,8]
>>> a[l] #array([30, 50, 60, 90])

values:[10,50,70,100]
---------------------------------
>>> a[[0,4,6,9]]

values:[10,100,50,70]
--------------------------------
>>> a[[0,9,4,6]]

values:[10,100]
-----------------------
>>> a[[0,-1]]
```
Access elements of 2-D array:
--------------------------------------------
```py
>>> l = [[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]]
>>> a = np.array(l)
>>> a

# I want to select:1,6,11,16
# Syntax:
#	a[[row_indices],[column_indices]]
#	a[[0,1,2,3],[0,1,2,3]]
#	It select elements from:(0,0),(1,1),(2,2) and (3,3)

>>> a[[0,1,2,3],[0,1,2,3]]
array([ 1,  6, 11, 16])

# Ex:To select:2,8,9,15
# ---------------------------------
>>> a[[0,1,2,3],[1,3,0,2]]

# L-Shape elements:
# ---------------------------
>>> a[[0,1,2,3,3,3,3],[0,0,0,0,1,2,3]]
array([ 1,  5,  9, 13, 14, 15, 16])
```

Accessing multiple arbitrary elements in 3-D array:
-----------------------------------------------------------------------------
```py
>>> a = np.arange(1,25).reshape(2,3,4)
>>> a

# Accessing 7 and 18 from the array

# Syntax:
#		a[[indices of 2d array],[row indices],[column indices]]
	
# Step-1:	7:						18:
#			i = 0					i = 1
#			j = 1					j = 1
#			k = 2					k = 1
#
#			i:[0,1]
#			j:[1,1]
#			k:[2,1]

>>>a[[0,1],[1,1],[2,1]]
array([ 7, 18])
```
Condition based selection:
---------------------------------------
We can select elements based on some condition also.
Syn:
>		array[boolean_array]
> In the boolean array, where ever True present the corresponding value will be selected.

```py
>>> a = np.array([10,20,30,40])
>>> boolean_array = np.array([True,False,False,True])
>>> a[boolean_array] #array([10, 40])

# select elements which are greater than 25
# ---------------------------------------------------------------
>>> b_a = a>25
>>> a[b_a]#array([30, 40])

>>> a[a>25]#array([30, 40])

Ex:
>>> a = np.array([10,-5,20,40,-3,-1,75])
>>> a #array([10, -5, 20, 40, -3, -1, 75])
>>> a[a < 0] #array([-5, -3, -1])
>>> a[a > 0] #array([10, 20, 40, 75])
>>> a[a%2 == 0] #array([10, 20, 40])
>>> a[a%5 == 0] #array([10, -5, 20, 40, 75])

# Condition based selection 2-D array also
# ------------------------------------------------------------
```py
>>> a = np.arange(1,26).reshape(5,5)
>>> a
>>> a[a%2 == 0]
>>> a[a%10 == 0]
```
## Slicing vs Advanced Indexing:

Python's Slicing:
---

In case of list, **slice operator will creates a separate copy**
If we perform **any changes in one copy those changes wont be reflected in other copy**.
```py
l1 = [10,20,30,40]
l2 = l1[:]
l2[1] = 333
l1[1] = 999
print(l1)
print(l2)
```
Numpy Array Slicing:
--------------------------------
**A separate copy wont be created and just we are getting view of the original copy**
```py
>>> a = np.arange(10,101,10)
>>> a
>>> b = a[0:4]
>>> b
>>> a[0] = 333
>>> a
>>> b
>>> b[1] = 999
>>> b
>>> a
```
##### Day-7 [1-03-2025]

Advanced Indexing and Condition Based selection:
---
	-->It will select required elements based on provided index or condition, and with those elements a new 1-D array object will be created.
	-->The output is always a new 1-D array only.

```py
>>> a = np.arange(10,101,10)
>>> a #array([ 10,  20,  30,  40,  50,  60,  70,  80,  90, 100])
>>> b = a[[0,2,5]]
>>> b #array([10, 30, 60])
>>> a[0] = 333
>>> a #array([333,  20,  30,  40,  50,  60,  70,  80,  90, 100])
>>> b #array([10, 30, 60])
>>> b[0]=999
>>> b #array([999,  30,  60])
>>> a #array([333,  20,  30,  40,  50,  60,  70,  80,  90, 100])
```
Slicing vs Advanced Indexing
--------------------------------------------
	Slicing:
		-->The elements should be ordered.
		-->We can't select arbitrary elements.
		-->Conditional based selection is not possible.
		-->Just we will get View but not copy.
		-->Memory, performance-wise it is the best.

	Advanced Indexing:
		-->The elements need not be ordered.
		-->We can select arbitrary elements
		-->Condition based selection is possible.
		-->Just we will get separate copy but not view.
		-->Memory, performance-wise not up to the mark

Summary of syntaxes:
---------------------------------
Basic Indexing:
-----------------------
	1-D array: a[i]
	2-D array: a[i][j] or a[i,j]
	3-D array: a[i][j][k] or a[i,j,k]

Slicing:
-----------
	1-D array: a[begin:end:step]
	2-D array: a[begin:end:step,begin:end:step]
	3-D array: a[begin:end:step,begin:end:step,begin:end:step]

Advanced Indexing:
-----------------------------
	1-D array: a[x]-->x contains ndarray or list
	2-D array: a[[row_indices],[column_indices]]
	3-D array: a[[indices of 2D array],[row_indices],[column_indices]]

Condition based selection:
----------------------------------------
	a[condition]==>a[a>0]
	This is same for all 1-D,2-D and 3-D arrays

## How to iterate elements of the ndarray:

Iteration means getting all elements one-by-one
--
	3-ways:
		1.By using python's loops
		2.By using nditer() function
		3.By using ndenumerate() function  


1 : By using python's loops
---

To iterate elements of 1-D array
-----------------------------------------------
```py
import numpy as np
a = np.arange(10,51,10)
for x in a:
	print(x)
```
To iterate elements of 2-D array
-----------------------------------------------
```py
import numpy as np
a = np.array([[10,20,30],[40,50,60],[70,80,90]])
for x in a:#x is 1-D array but not scalar value
	for y in x:#y is a scalar value present in 1-D array
		print(y)
```
To iterate elements of 3-D array
------------------------------------------------
```py
import numpy as np
a = np.array([[[10,20],[30,40]],[[50,60],[70,80]]])
for x in a:#x is 2-D array but not scalar value
	for y in x:#y is 1-D array but not scalar value
		for z in y:#z is a scalar value
			print(z)
```
> [!Note]
> To iterate elements of n-D array, we required n-loops.

2 : By using numpy's nditer()
---------------------------------------
> [!Note]
> Advantage: For any n-D array only one loop is enough.

	nditer is a class present in numpy module.
	nditer() ---> Creating an object of inditer class.

1-D array:
---------------
```py
import numpy as np
a = np.arange(10,51,10)
for x in np.nditer(a):
	print(x)
```
2-D array:
---------------
```py
a = np.array([[10,20,30],[40,50,60],[70,80,90]])
for x in np.nditer(a):
	print(x)
```
3-D array:
---------------
```
a = np.array([[[10,20],[30,40]],[[50,60],[70,80]]])
for x in np.nditer(a):
	print(x)
```
Iterate elements of slicied array:
------------------------------------------------
```py
import numpy as np
a = np.array([[10,20,30],[40,50,60],[70,80,90]])
for x in np.nditer(a[:,:2]):
	print(x)
```
Using nditer() to get elements of required data type:
------------------------------------------------------------------------------
```py
# We have to use op_dtypes
>>>help(np.nditer)

a = np.array([[10,20,30],[40,50,60],[70,80,90]])
for x in np.nditer(a,flags=['buffered'],op_dtypes=['float']):
	print(x)
print(a)
```
Normal Python loops vs nditer():
------------------------------------------------

| Python loops | nditer |
|:--------------|:--------------|
| **n-loops** are required.|Only **one loop** is enough.| 
| Can not specify our required **dtype**. | Can specify required **dtype** by using **op_dtypes** argument.  |


##### Day-8 [3-03-2025]

3: By using ndenumerate() function
----------------------------------------------------
	If we want to find co-ordinates also in addition to element.
	array indices(coordinates) and values

1-D array
-------------------
```py
import numpy as np
a = np.array([10,20,30,40,50])
for pos,element in np.ndenumerate(a):
	print(f'{element} element present at index/position:{pos}')
```
2-D array:
---------------
```py
a = np.array([[10,20,30],[40,50,60],[70,80,90]])
for pos,element in np.ndenumerate(a):
	print(f'{element} element present at index/position:{pos}')
```
3-D array:
---------------
```py
a = np.arange(1,25).reshape(2,3,4)
for pos,element in np.ndenumerate(a):
	print(f'{element} element present at index/position:{pos}')
```
## Arithmetic operators:

		+, -, *, /, **, //

1-D array:
---------------
```py
>>> a = np.array([10,20,30,40])
>>> a #array([10, 20, 30, 40])
>>> a+2 #array([12, 22, 32, 42])
>>> a-2 #array([ 8, 18, 28, 38])
>>> a*2 #array([20, 40, 60, 80])
>>> a%2 #array([0, 0, 0, 0], dtype=int32)
>>> a/2 #array([ 5., 10., 15., 20.])
>>> a//2 #array([ 5, 10, 15, 20], dtype=int32)
```
2-D array:
--------------
```py
>>> a = np.array([[10,20,30],[40,50,60]])
>>> a
>>> a+2
>>> a-2
>>> a*2
>>> a**2
>>> a/2
>>> a//2
```

>[!Note]
>In python anything by zero including zero/zero results is : **ZeroDivisionError**
>
>But in Numpy there is **no ZeroDivisionError.**  
>10/0==>Infinity(inf)  
>0/0==>undefined(nan-->not a number)

Ex:
```py
>>> a = np.arange(6)
>>> a/0 #array([nan, inf, inf, inf, inf, inf])
```
Arithmetic operators for Arrays with Arrays:
------------------------------------------------------------------
	Compulsory both arrays should have:  
		--> Same dimension  
		--> Same shape and
		--> Same size
	-->otherwise we will get error.

1-D array:
---------------
```py
>>> a = np.array([1,2,3,4])
>>> b = np.array([10,20,30,40])
>>> a.ndim
>>> b.ndim
>>> a.shape
>>> b.shape
>>> a.size
>>> b.size
>>> a+b
>>> a-b
>>> a*b
>>> b/a
>>> b//a
```
2-D array
-------------
```py
>>> a = np.array([[1,2],[3,4]])
>>> b = np.array([[5,6],[7,8]])
>>> a+b
>>> a-b
>>> a*b
>>> b/a
>>> b//a
```
When shape is not same.  
Ex:
```py
>>> a = np.array([10,20,30])
>>> b = np.array([10,20,30,40])
>>> a+b
ValueError: operands could not be broadcast together with shapes (3,) (4,)
```
Equivalent numpy library function for arithmetic operators :
------------------------------------------------------------------------------------
universal function (ufunc) in the NumPy library that performs **element-wise addition of two arrays or a scalar and an array.**
```py
>>> a = np.array([10,20,30])
>>> b = np.array([1,2,3])
>>> np.add(a,b)
>>> np.subtract(a,b)
>>> np.multiply(a,b)
>>> np.divide(a,b)
>>> np.floor_divide(a,b)
>>> np.mod(a,b)
>>> np.power(a,b)
```
>[!Note]
>The functions which operates element by element on whole array are called as Universal functions(ufunc).

Broadcasting:
--------------------

>Eventhough **dimensions are different**, **shapes are different** and **sizes are different** **still some arithmetic operations are allowed by Broadcasting**.

>[!Note]
>Broadcasting will be **performed automatically by numpy itself** and we are not required to perform explicitly.

Rules for Broadcasting:
-----------------------------------
Rule-1:
-------
	Make sure both arrays should have same dimension  
	Padded(Add) 1's in the shape of lesser dimension array on the left side, until both arrays have same dimension.

	Before:
		(4,3)--->2-D
		(3,)---->1-D

	After:
		(4,3)--->2-D
		(1,3)--->2-D

Rule-2:
----------
	If the size of 2-arrays does not match in any dimension,
	then the arrays with size equal to 1 in that dimension will be increased to the size of other dimension to match.

	Note:
		If any dimension, the sizes are not matched and neither equal to 1,
		then we will get an error, Numpy does not able to perform broadcasting between those arrays.

	Before:
		(4,3)-->2-D
		(1,3)-->2-D

	Afetr:
		(4,3)-->2-D
		(4,3)-->2-D

	-->Now dimensions, shapes and size are equal.

Ex-2:
--------
```py
Broadcasting between (3,2,2) and (3,) possible or not
Before Rule-1:
	(3,2,2)
	(3,)
After Rule-1:
	(3,2,2)
	(1,1,3)

After Rule-2:
	(3,2,2)
	(3,2,3)

same dimension, but different shapes, so numpy unable to perform broacasting.

Note:
	The data will be reused from the same input array
	If the rows are required then re-use existing row
	If the columns are required then re-use existing columns
	The result is always higher dimension of input arrays
	input:3-D,1-D
	output:3-D

>>> a = np.array([10,20,30])	--->1-D	shape(3,)
>>> b = np.array([40])				--->1-D	shape(1,)
>>> a+b
array([50, 60, 70])	
```
Ex:
```py
>>> a = np.array([[10,20],[30,40],[50,60]])		--->2-D	shape(3,2)
>>> b = np.array([10,20])					-->1-D	shape(2,)
>>> a+b
array([[20, 40],
       [40, 60],
       [60, 80]])
```
Ex:
```py
>>> a = np.array([[10],[20],[30]])		-->2-D	shape(3,1)
>>> b = np.array([10,20,30])		-->1-D	shape(3,)
>>> a+b
array([[20, 30, 40],
       [30, 40, 50],
       [40, 50, 60]])
```

## Array Manipulation functions:
* 1.reshape()
* 2.resize()
* 3.flatten()
* 4.flat variable
* 5.ravel()
* 6.transpose()
* 7.swapaxes()

##### Day-9 [4-03-2025]

1.reshape():
----
	shape to another shape
	(10,)--->(5,2),(2,5),(10,1),(1,10)
	(24,)--->(3,8)-->(2,3,4),(6,4),(2,2,2,3)

1).The **data remian same** shoud not be changed and **input size and output size** must be matched .

Ex:
```py
>>> import numpy as np
>>> a = np.arange(10)
>>> a
>>> a.ndim #1
>>> a.shape #(10,)
>>> b = np.reshape(a,(5,2))
>>> b
>>> b = np.reshape(a,(10,1))
>>> b
>>> b = np.reshape(a,(1,5,2))#3-D array 5-rows and 2-columns
>>> b
```
Ex:
```py
>>> a = np.arange(24)
>>> a
>>> b = np.reshape(a,(6,4))
>>> b
>>> b = np.reshape(a,(2,3,4))
>>> b
>>> b = np.reshape(a,(6,5))
ValueError: cannot reshape array of size 24 into shape (6,5)
```
2).No change in the data.  
**New array object won't be created.**  
Just we are getting view of existing object,**view but not copy.**  
If we perform any **changes in the original array, that change will be reflected to reshaped array**. Viceversa.
```py
>>> a = np.arange(12)
>>> a
>>> b = np.reshape(a,(4,3))
>>> b
>>> a[0] = 333
>>> a
>>> b
>>> b[1][1] = 999
>>> b
>>> a
```
3). we can specify **unknown dimension size as -1.**

Ex:
```py
# a = (12,)
# b = (6,-1)===>(6,2)

>>> a = np.arange(12)
>>> b = np.reshape(a,(6,2))
>>> b
>>> b = np.reshape(a,(6,-1))
>>> b
>>> b = np.reshape(a,(-1,3))
>>> b
>>> b = np.reshape(a,(-1,-1))#Error

>>> a = np.arange(24)
>>> b = np.reshape(a,(2,3,-1))
>>> b = np.reshape(a,(2,-1,4))
>>> b = np.reshape(a,(-1,3,4))
>>> b = np.reshape(a,(3,4,-1))
>>> b = np.reshape(a,(5,-1))#Error
```
4).
```py
help(np.reshape)  
		reshape(a, newshape, order='C')
```
C style -->**Row major order**  
Fortran style --->**Column major order**

```py
>>> a = np.arange(12).reshape(3,4)
>>> a
>>> b = np.reshape(a,(12,),'C')
>>> b #array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11])
>>> b = np.reshape(a,(12,),'F')
>>> b #array([ 0,  4,  8,  1,  5,  9,  2,  6, 10,  3,  7, 11])
```
Ex:
```py
>>> a = np.arange(24,)
>>> a
>>> np.reshape(a,(6,4),'C')
>>> np.reshape(a,(6,4),'F')
```
Conclusion:
-----------------
>[!Note]
>1.To reshape array without changing data.  
>2.The size must be matched.  
>3.We can use either numpy library function or ndarray class method  
>				np.reshape()  
>				a.reshape()  
>4.It wont create a new array object, just we will get view.  
>5.We can use -1 in unknown dimension, but only once.  
>6.Order:'C','F'  

2).resize():
---------------
>[!Note]
>output array: can be any dimension, any shape, any size

	1).Input size and output size need not be matched.
	2).The data may be changed
	3).We will get copy but not view
	4).How to get that new data
			np.resize()--->repeat elements of input array
			a.resize()--->use zero for extra elements
	5). -1 such type of story not applicable for resize()
			input:(10,)
			reshape:(5,-1)
			resize:(5,-1)
	6).If we use ndarray class resize() method, inline modification will be happended.

Ex:
```py
>>> a = np.arange(1,6)
>>> a
>>> b = np.resize(a,(4,3))
>>> b
>>> a[0] = 333
>>> a
>>> b
>>> b[0][1]=999
>>> b
>>> a
>>> refcheck=False
>>> a = np.arange(1,6)
>>> a.resize(5,3)
>>> a
```

Q.Difference between np.resize() and ndarray.resize()?
------------------------------------------------------

| np.resize()     | ndarray.resize() |
|:----------------|:-----------------|
| 1). It is library function in numpy module. | 1). It is method present in ndarray class|
| 2). It will create new array and returned it.| 2). It wont return new array and existing array will be modified.|
|3). If the newshape required more elements then repeated copies of original array will be reused.|3). Extra elements filled with zeros. |

Q.Differences between reshape() and resize()?
-----------------------------------------------

| reshape()     | resize() |
|:----------------|:-----------------|
|1.It is just to reshape to array without changing size and data.|1.It is to resize() array, data may be changes, size may be changed.|
|2.Just view will be created but not copy,if we perform any change in the original array,automatically those changes will be reflected in reshaped copy also. |2.Separate copy will be created. If we perform any changes in the original array those changes wont be reflected in 	resize array.|
|3.We can use -1 in unknown dimension.|3.There is no story like -1.|
